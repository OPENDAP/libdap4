<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdap: libdap::chunked_outbuf Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.20.6</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibdap_1_1chunked__outbuf.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibdap_1_1chunked__outbuf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libdap::chunked_outbuf Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>output buffer for a chunked stream This performs buffered output encoding the data in the stream using the simple chunking protocol defined for DAP4's binary data transmission. Each block of data is prefixed by four bytes: A CHUNK TYPE byte followed by three bytes that are the CHUNK SIZE. There are three CHUNK TYPES: data, end and error, indicated by the code values 0x00, 0x01 and 0x02. The size of a chunk is limited to 2^24 data bytes + 4 bytes for the chunk header.  
 <a href="classlibdap_1_1chunked__outbuf.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="chunked__ostream_8h_source.html">chunked_ostream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libdap::chunked_outbuf:</div>
<div class="dyncontent">
<div class="center"><img src="classlibdap_1_1chunked__outbuf__inherit__graph.png" border="0" usemap="#libdap_1_1chunked__outbuf_inherit__map" alt="Inheritance graph"/></div>
<map name="libdap_1_1chunked__outbuf_inherit__map" id="libdap_1_1chunked__outbuf_inherit__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b5484aefc52663318e90a6d3dabc395"><td class="memItemLeft" align="right" valign="top"><a id="a7b5484aefc52663318e90a6d3dabc395"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>chunked_outbuf</b> (std::ostream &amp;os, unsigned int buf_size)</td></tr>
<tr class="separator:a7b5484aefc52663318e90a6d3dabc395"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2eb3a61bf3e82204a8ffca358558dead"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#a2eb3a61bf3e82204a8ffca358558dead">data_chunk</a> ()</td></tr>
<tr class="memdesc:a2eb3a61bf3e82204a8ffca358558dead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out the contents of the buffer as a chunk.  <a href="#a2eb3a61bf3e82204a8ffca358558dead">More...</a><br /></td></tr>
<tr class="separator:a2eb3a61bf3e82204a8ffca358558dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6c9891d360d5d9b7085ec8cf543610"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#a1c6c9891d360d5d9b7085ec8cf543610">end_chunk</a> ()</td></tr>
<tr class="memdesc:a1c6c9891d360d5d9b7085ec8cf543610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an end chunk.  <a href="#a1c6c9891d360d5d9b7085ec8cf543610">More...</a><br /></td></tr>
<tr class="separator:a1c6c9891d360d5d9b7085ec8cf543610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefa71794597aa2b9edcfc9d7101bba1"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#abefa71794597aa2b9edcfc9d7101bba1">err_chunk</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:abefa71794597aa2b9edcfc9d7101bba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an error chunk While building up the next chunk, send an error chunk, ignoring the data currently write buffer. The buffer is left in a consistent state.  <a href="#abefa71794597aa2b9edcfc9d7101bba1">More...</a><br /></td></tr>
<tr class="separator:abefa71794597aa2b9edcfc9d7101bba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3250bbda968c561cfb390ba77504db"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#ade3250bbda968c561cfb390ba77504db">overflow</a> (int c)</td></tr>
<tr class="memdesc:ade3250bbda968c561cfb390ba77504db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method called when the internal buffer would overflow. When the internal buffer fills, this method is called by the byte that would cause that overflow. The buffer pointers have been set so that there is actually space for one more character, so <code>c</code> can really be sent. Put <code>c</code> into the buffer and send it, prefixing the buffer contents with a chunk header.  <a href="#ade3250bbda968c561cfb390ba77504db">More...</a><br /></td></tr>
<tr class="separator:ade3250bbda968c561cfb390ba77504db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31279e06619ddbe49382adf03cf5803"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#ad31279e06619ddbe49382adf03cf5803">sync</a> ()</td></tr>
<tr class="memdesc:ad31279e06619ddbe49382adf03cf5803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the stream with its data sink.  <a href="#ad31279e06619ddbe49382adf03cf5803">More...</a><br /></td></tr>
<tr class="separator:ad31279e06619ddbe49382adf03cf5803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bcec83a5f20ac5a8f76e3c490d0768"><td class="memItemLeft" align="right" valign="top">virtual std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__outbuf.html#a07bcec83a5f20ac5a8f76e3c490d0768">xsputn</a> (const char *s, std::streamsize num)</td></tr>
<tr class="memdesc:a07bcec83a5f20ac5a8f76e3c490d0768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write bytes to the chunked stream Write the bytes in <code>s</code> to the chunked stream.  <a href="#a07bcec83a5f20ac5a8f76e3c490d0768">More...</a><br /></td></tr>
<tr class="separator:a07bcec83a5f20ac5a8f76e3c490d0768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af880ffbdbba0d1431be7b216889a9978"><td class="memItemLeft" align="right" valign="top"><a id="af880ffbdbba0d1431be7b216889a9978"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>d_big_endian</b></td></tr>
<tr class="separator:af880ffbdbba0d1431be7b216889a9978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ec24aa5c42f065fe4e562a05932755"><td class="memItemLeft" align="right" valign="top"><a id="a74ec24aa5c42f065fe4e562a05932755"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>d_buf_size</b></td></tr>
<tr class="separator:a74ec24aa5c42f065fe4e562a05932755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bb0a16e9f3a1b1818598738721a6cd"><td class="memItemLeft" align="right" valign="top"><a id="a35bb0a16e9f3a1b1818598738721a6cd"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>d_buffer</b></td></tr>
<tr class="separator:a35bb0a16e9f3a1b1818598738721a6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c91bdcef81b9f954065de58d6690f"><td class="memItemLeft" align="right" valign="top"><a id="a113c91bdcef81b9f954065de58d6690f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>d_os</b></td></tr>
<tr class="separator:a113c91bdcef81b9f954065de58d6690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae2a1ee739728da6bb7001bebd357b036"><td class="memItemLeft" align="right" valign="top"><a id="ae2a1ee739728da6bb7001bebd357b036"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>chunked_ostream</b></td></tr>
<tr class="separator:ae2a1ee739728da6bb7001bebd357b036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>output buffer for a chunked stream This performs buffered output encoding the data in the stream using the simple chunking protocol defined for DAP4's binary data transmission. Each block of data is prefixed by four bytes: A CHUNK TYPE byte followed by three bytes that are the CHUNK SIZE. There are three CHUNK TYPES: data, end and error, indicated by the code values 0x00, 0x01 and 0x02. The size of a chunk is limited to 2^24 data bytes + 4 bytes for the chunk header. </p>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8h_source.html#l00053">53</a> of file <a class="el" href="chunked__ostream_8h_source.html">chunked_ostream.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2eb3a61bf3e82204a8ffca358558dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb3a61bf3e82204a8ffca358558dead">&#9670;&nbsp;</a></span>data_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_outbuf::data_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write out the contents of the buffer as a chunk. </p>
<dl class="section return"><dt>Returns</dt><dd>EOF on error, otherwise the number of bytes in the chunk body. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00054">54</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<a id="a1c6c9891d360d5d9b7085ec8cf543610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6c9891d360d5d9b7085ec8cf543610">&#9670;&nbsp;</a></span>end_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_outbuf::end_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an end chunk. </p>
<p>This is like calling flush_chunk(), but it sends a chunk header with a type of CHUNK_END (instead of CHUNK_DATA). Whatever is in the buffer is written out, but the stream is can be used to send more chunks. </p><dl class="section note"><dt>Note</dt><dd>This is called by the <a class="el" href="classlibdap_1_1chunked__outbuf.html" title="output buffer for a chunked stream This performs buffered output encoding the data in the stream usin...">chunked_outbuf</a> destructor, so closing a stream using <a class="el" href="classlibdap_1_1chunked__outbuf.html" title="output buffer for a chunked stream This performs buffered output encoding the data in the stream usin...">chunked_outbuf</a> always sends a CHUNK_END type chunk, even if it will have zero bytes </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EOF on error, otherwise the number of bytes sent in the chunk. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00108">108</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<a id="abefa71794597aa2b9edcfc9d7101bba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefa71794597aa2b9edcfc9d7101bba1">&#9670;&nbsp;</a></span>err_chunk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_outbuf::err_chunk </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an error chunk While building up the next chunk, send an error chunk, ignoring the data currently write buffer. The buffer is left in a consistent state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The error message to include in the error chunk </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters ignored. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00150">150</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<a id="ade3250bbda968c561cfb390ba77504db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3250bbda968c561cfb390ba77504db">&#9670;&nbsp;</a></span>overflow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_outbuf::overflow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method called when the internal buffer would overflow. When the internal buffer fills, this method is called by the byte that would cause that overflow. The buffer pointers have been set so that there is actually space for one more character, so <code>c</code> can really be sent. Put <code>c</code> into the buffer and send it, prefixing the buffer contents with a chunk header. </p>
<dl class="section note"><dt>Note</dt><dd>This method is called by the std::ostream code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The last character to add to the buffer before sending the next chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EOF on error, otherwise the value of <code>c</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00205">205</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<a id="ad31279e06619ddbe49382adf03cf5803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31279e06619ddbe49382adf03cf5803">&#9670;&nbsp;</a></span>sync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_outbuf::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize the stream with its data sink. </p>
<dl class="section note"><dt>Note</dt><dd>This method is called by flush() among others </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, 0 otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00329">329</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<a id="a07bcec83a5f20ac5a8f76e3c490d0768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bcec83a5f20ac5a8f76e3c490d0768">&#9670;&nbsp;</a></span>xsputn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize libdap::chunked_outbuf::xsputn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write bytes to the chunked stream Write the bytes in <code>s</code> to the chunked stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written </dd></dl>

<p class="definition">Definition at line <a class="el" href="chunked__ostream_8cc_source.html#l00247">247</a> of file <a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="chunked__ostream_8h_source.html">chunked_ostream.h</a></li>
<li><a class="el" href="chunked__ostream_8cc_source.html">chunked_ostream.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1chunked__outbuf.html">chunked_outbuf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
