<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libdap: libdap::DAPCache3 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.20.0</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibdap_1_1DAPCache3.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classlibdap_1_1DAPCache3-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libdap::DAPCache3 Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of a caching mechanism for compressed data. This cache uses simple advisory locking found on most modern unix file systems. Compressed files are decompressed and stored in a cache where they can be used over and over until removed from the cache. Several processes can share the cache with each reading from files. At the same time, new files can be added and the cache can be purged, without disrupting the existing read operations.  
 <a href="classlibdap_1_1DAPCache3.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DAPCache3_8h_source.html">DAPCache3.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libdap::DAPCache3:</div>
<div class="dyncontent">
<div class="center"><img src="classlibdap_1_1DAPCache3__inherit__graph.png" border="0" usemap="#libdap_1_1DAPCache3_inherit__map" alt="Inheritance graph"/></div>
<map name="libdap_1_1DAPCache3_inherit__map" id="libdap_1_1DAPCache3_inherit__map">
<area shape="rect" id="node2" href="classlibdap_1_1DapObj.html" title="libdap base object for common functionality of libdap objects " alt="" coords="47,5,158,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81ad790f2299181820b66d66111d456c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a81ad790f2299181820b66d66111d456c">cache_too_big</a> (unsigned long long current_size) const </td></tr>
<tr class="memdesc:a81ad790f2299181820b66d66111d456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">look at the cache size; is it too large? Look at the cache size and see if it is too big.  <a href="#a81ad790f2299181820b66d66111d456c">More...</a><br /></td></tr>
<tr class="separator:a81ad790f2299181820b66d66111d456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf4ad0cb6808bf453a262d29b8f6169"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#afcf4ad0cb6808bf453a262d29b8f6169">create_and_lock</a> (const string &amp;target, int &amp;fd)</td></tr>
<tr class="memdesc:afcf4ad0cb6808bf453a262d29b8f6169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file in the cache and lock it for write access. If the file does not exist, make it, open it for read-write access and get an exclusive lock on it. The locking operation blocks, although that should never happen.  <a href="#afcf4ad0cb6808bf453a262d29b8f6169">More...</a><br /></td></tr>
<tr class="separator:afcf4ad0cb6808bf453a262d29b8f6169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bd8728a086dc2c9f704b89f662ca29"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DapObj.html#a99bd8728a086dc2c9f704b89f662ca29">dump</a> (std::ostream &amp;strm) const  =0</td></tr>
<tr class="memdesc:a99bd8728a086dc2c9f704b89f662ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">dump the contents of this object to the specified ostream  <a href="#a99bd8728a086dc2c9f704b89f662ca29">More...</a><br /></td></tr>
<tr class="separator:a99bd8728a086dc2c9f704b89f662ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a93fbca664f0a060a28f5709c72c6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a09a93fbca664f0a060a28f5709c72c6e">dump</a> (ostream &amp;strm) const </td></tr>
<tr class="memdesc:a09a93fbca664f0a060a28f5709c72c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps information about this object  <a href="#a09a93fbca664f0a060a28f5709c72c6e">More...</a><br /></td></tr>
<tr class="separator:a09a93fbca664f0a060a28f5709c72c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b43f4929a90b4708c155257b40fae2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a89b43f4929a90b4708c155257b40fae2">exclusive_to_shared_lock</a> (int fd)</td></tr>
<tr class="memdesc:a89b43f4929a90b4708c155257b40fae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer from an exclusive lock to a shared lock. If the file has an exclusive write lock on it, change that to a shared read lock. This is an atomic operation. If the call to fcntl(2) is protected by locking the cache, a dead lock will result given typical use of this class. This method exists to help with the situation where one process has the cache locked and is blocking on a shared read lock for a file that a second process has locked exclusively (for writing). By changing the exclusive lock to a shared lock, the first process can get its shared lock and then release the cache.  <a href="#a89b43f4929a90b4708c155257b40fae2">More...</a><br /></td></tr>
<tr class="separator:a89b43f4929a90b4708c155257b40fae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620d839ba6727d0245c61541ef8e6d0"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a3620d839ba6727d0245c61541ef8e6d0">get_cache_file_name</a> (const string &amp;src, bool mangle=true)</td></tr>
<tr class="separator:a3620d839ba6727d0245c61541ef8e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cccf6a9c84957acf358418f2f920fe"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a20cccf6a9c84957acf358418f2f920fe">get_cache_size</a> ()</td></tr>
<tr class="memdesc:a20cccf6a9c84957acf358418f2f920fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache size. Read the size information from the cache info file and return it. This methods locks the cache.  <a href="#a20cccf6a9c84957acf358418f2f920fe">More...</a><br /></td></tr>
<tr class="separator:a20cccf6a9c84957acf358418f2f920fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5065a7f6678bdb34ba3e9615e9f5554e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a5065a7f6678bdb34ba3e9615e9f5554e">get_read_lock</a> (const string &amp;target, int &amp;fd)</td></tr>
<tr class="memdesc:a5065a7f6678bdb34ba3e9615e9f5554e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only lock on the file if it exists.  <a href="#a5065a7f6678bdb34ba3e9615e9f5554e">More...</a><br /></td></tr>
<tr class="separator:a5065a7f6678bdb34ba3e9615e9f5554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b68e963914b0fe307a37b86a6986599"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a8b68e963914b0fe307a37b86a6986599">lock_cache_read</a> ()</td></tr>
<tr class="separator:a8b68e963914b0fe307a37b86a6986599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75c177ee450c8f18e3570c0ebefd8ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#af75c177ee450c8f18e3570c0ebefd8ac">lock_cache_write</a> ()</td></tr>
<tr class="separator:af75c177ee450c8f18e3570c0ebefd8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd52daa0ae17a1b3abc84473d0e66e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a48cd52daa0ae17a1b3abc84473d0e66e">purge_file</a> (const string &amp;file)</td></tr>
<tr class="memdesc:a48cd52daa0ae17a1b3abc84473d0e66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge a single file from the cache.  <a href="#a48cd52daa0ae17a1b3abc84473d0e66e">More...</a><br /></td></tr>
<tr class="separator:a48cd52daa0ae17a1b3abc84473d0e66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee589484c58c3c6959000fae1e010a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee589484c58c3c6959000fae1e010a4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_and_close</b> (const string &amp;target)</td></tr>
<tr class="separator:a8ee589484c58c3c6959000fae1e010a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782bf630f76e5bcab4c356db6101d346"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a782bf630f76e5bcab4c356db6101d346">unlock_and_close</a> (int fd)</td></tr>
<tr class="separator:a782bf630f76e5bcab4c356db6101d346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f2d56a33176ac93ade3bf16c6c7ec6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#a72f2d56a33176ac93ade3bf16c6c7ec6">unlock_cache</a> ()</td></tr>
<tr class="separator:a72f2d56a33176ac93ade3bf16c6c7ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae115f42c90bdadc1e6700994c85c9176"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#ae115f42c90bdadc1e6700994c85c9176">update_and_purge</a> (const string &amp;new_file)</td></tr>
<tr class="memdesc:ae115f42c90bdadc1e6700994c85c9176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge files from the cache.  <a href="#ae115f42c90bdadc1e6700994c85c9176">More...</a><br /></td></tr>
<tr class="separator:ae115f42c90bdadc1e6700994c85c9176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cc2b1e37e3c54080bb38d1abbc3b60"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#ac3cc2b1e37e3c54080bb38d1abbc3b60">update_cache_info</a> (const string &amp;target)</td></tr>
<tr class="memdesc:ac3cc2b1e37e3c54080bb38d1abbc3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cache info file to include 'target'.  <a href="#ac3cc2b1e37e3c54080bb38d1abbc3b60">More...</a><br /></td></tr>
<tr class="separator:ac3cc2b1e37e3c54080bb38d1abbc3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0e83e7a3f68d1cf5ca6417021dd05e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e83e7a3f68d1cf5ca6417021dd05e2d"></a>
static <a class="el" href="classlibdap_1_1DAPCache3.html">DAPCache3</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_instance</b> (const string &amp;cache_dir, const string &amp;prefix, unsigned long long size)</td></tr>
<tr class="separator:a0e83e7a3f68d1cf5ca6417021dd05e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa607870d67dba981060b5fd4b0b768"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibdap_1_1DAPCache3.html">DAPCache3</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1DAPCache3.html#adfa607870d67dba981060b5fd4b0b768">get_instance</a> ()</td></tr>
<tr class="separator:adfa607870d67dba981060b5fd4b0b768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a caching mechanism for compressed data. This cache uses simple advisory locking found on most modern unix file systems. Compressed files are decompressed and stored in a cache where they can be used over and over until removed from the cache. Several processes can share the cache with each reading from files. At the same time, new files can be added and the cache can be purged, without disrupting the existing read operations. </p>
<p>How it works. When a file is added to the cache, the cache is locked - no other processes can add, read or remove files. Once a file has been added, the cache size is examined and, if needed, the cache is purged so that its size is 80% of the maximum size. Then the cache is unlocked. When a process looks to see if a file is already in the cache, the entire cache is locked. If the file is present, a shared read lock is obtained and the cache is unlocked.</p>
<p>Methods: <a class="el" href="classlibdap_1_1DAPCache3.html#afcf4ad0cb6808bf453a262d29b8f6169" title="Create a file in the cache and lock it for write access. If the file does not exist, make it, open it for read-write access and get an exclusive lock on it. The locking operation blocks, although that should never happen. ">create_and_lock()</a> and <a class="el" href="classlibdap_1_1DAPCache3.html#a5065a7f6678bdb34ba3e9615e9f5554e" title="Get a read-only lock on the file if it exists. ">get_read_lock()</a> open and lock files; the former creates the file and locks it exclusively iff it does not exist, while the latter obtains a shared lock iff the file already exists. The unlock() methods unlock a file. The lock_cache_info() and unlock_cache_info() are used to control access to the whole cache - with the open + lock and close + unlock operations performed atomically. Other methods that operate on the cache info file must only be called when the lock has been obtained. </p>

<p>Definition at line <a class="el" href="DAPCache3_8h_source.html#l00082">82</a> of file <a class="el" href="DAPCache3_8h_source.html">DAPCache3.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a81ad790f2299181820b66d66111d456c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::DAPCache3::cache_too_big </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>current_size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>look at the cache size; is it too large? Look at the cache size and see if it is too big. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the size is too big, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00760">760</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afcf4ad0cb6808bf453a262d29b8f6169"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::DAPCache3::create_and_lock </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a file in the cache and lock it for write access. If the file does not exist, make it, open it for read-write access and get an exclusive lock on it. The locking operation blocks, although that should never happen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the file to make/open/lock </td></tr>
    <tr><td class="paramname">fd</td><td>Value-result param that holds the file descriptor of the opened file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the operation was successful, false otherwise. This method will return false if the file already existed (the file won't be locked and the descriptor reference is undefined - but likely -1). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">BESInternalError</td><td>if any error except EEXIST is returned by open(2) or if fcntl(2) returns an error. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00590">590</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a99bd8728a086dc2c9f704b89f662ca29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libdap::DapObj::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dump the contents of this object to the specified ostream </p>
<p>This method is implemented by all derived classes to dump their contents, in other words, any state they might have, private variables, etc...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>C++ i/o stream to dump the object to </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlibdap_1_1DDS.html#aebc046a3091961db2802334ddc9280e0">libdap::DDS</a>, <a class="el" href="classlibdap_1_1AttrTable.html#aa83039e176ada59b990c68b6f3c2cdb7">libdap::AttrTable</a>, <a class="el" href="classlibdap_1_1Sequence.html#acd0961a9479c9224d7b08021bb4d0c36">libdap::Sequence</a>, <a class="el" href="classlibdap_1_1D4Sequence.html#a32a1e81ee72ebad64a1f706da03af2b4">libdap::D4Sequence</a>, <a class="el" href="classlibdap_1_1Array.html#a292d09e6995cbe722e92973c9dc98c7f">libdap::Array</a>, <a class="el" href="classlibdap_1_1Vector.html#a719617cae1386c64723abf845651ed4d">libdap::Vector</a>, <a class="el" href="classlibdap_1_1Grid.html#a1ebdcb9b7a3844582c543acaf20cc07c">libdap::Grid</a>, <a class="el" href="classlibdap_1_1DAS.html#a7acd3373e34b8776f08c2a8e49f6fa01">libdap::DAS</a>, <a class="el" href="classlibdap_1_1D4Enum.html#a94c43aa9f183065de775a24d89542cb7">libdap::D4Enum</a>, <a class="el" href="classlibdap_1_1DMR.html#a7eaad27fff29be08a5fc66f5845013b1">libdap::DMR</a>, <a class="el" href="classlibdap_1_1D4StreamMarshaller.html#ab9d34bcac045b972370802cac3094d45">libdap::D4StreamMarshaller</a>, <a class="el" href="classlibdap_1_1BaseType.html#a1ecd80ca994b950bd19b5f525fa4c7a2">libdap::BaseType</a>, <a class="el" href="classlibdap_1_1D4Attributes.html#a6c3412142fbb8f9c6774e8b682bcca6f">libdap::D4Attributes</a>, <a class="el" href="classlibdap_1_1D4StreamUnMarshaller.html#a05a758856478355284f43cff8e43f5ac">libdap::D4StreamUnMarshaller</a>, <a class="el" href="classlibdap_1_1Constructor.html#af411561f4f57c632b4d0a6f091f98ce4">libdap::Constructor</a>, <a class="el" href="classlibdap_1_1DataDDS.html#a7241f19eb2d6949cd3dd5522fbd85966">libdap::DataDDS</a>, <a class="el" href="classlibdap_1_1Str.html#ad706e5b2b72822d8a5a30cf9c50ce570">libdap::Str</a>, <a class="el" href="classlibdap_1_1Int32.html#a385daf822e17979dbcb9b4c219020556">libdap::Int32</a>, <a class="el" href="classlibdap_1_1Structure.html#ad7aacbec3d542618fa6ba4f42e3dde9a">libdap::Structure</a>, <a class="el" href="classlibdap_1_1D4Opaque.html#a52e8aa26647d26fa064ba4342e12de0b">libdap::D4Opaque</a>, <a class="el" href="classlibdap_1_1Float32.html#a8244fea2d040cdf884648cebd9892d46">libdap::Float32</a>, <a class="el" href="classlibdap_1_1Byte.html#a7a8dcba1239f9e3f3f40f622fc3ce859">libdap::Byte</a>, <a class="el" href="classlibdap_1_1Marshaller.html#acf0d1bbcde8e6f80fa7bf7041a734e97">libdap::Marshaller</a>, <a class="el" href="classlibdap_1_1Float64.html#a86485dcfe248c7fe06d33d50887c686e">libdap::Float64</a>, <a class="el" href="classlibdap_1_1Int16.html#ab58ac36f1a81dbfe6dcb99a58ed1140e">libdap::Int16</a>, <a class="el" href="classlibdap_1_1UInt32.html#a145819d11b103bb06e6f2b8aad03b070">libdap::UInt32</a>, <a class="el" href="classlibdap_1_1XDRStreamMarshaller.html#ab479a67018cfb49a9e3f46c7aad85302">libdap::XDRStreamMarshaller</a>, <a class="el" href="classlibdap_1_1UInt16.html#a7a497c9339a553c94a55fda54bf5ea31">libdap::UInt16</a>, <a class="el" href="classlibdap_1_1D4Attribute.html#a1c65a524ff5583324ba8c442393cac14">libdap::D4Attribute</a>, <a class="el" href="classlibdap_1_1Int64.html#a64f428e1541b2a0300e0dd85e4d5c75c">libdap::Int64</a>, <a class="el" href="classlibdap_1_1UInt64.html#a61f737132eb7ca9d01ab81b2f4554535">libdap::UInt64</a>, <a class="el" href="classlibdap_1_1XDRStreamUnMarshaller.html#a709892593023e5ea542a0d24541c13d9">libdap::XDRStreamUnMarshaller</a>, <a class="el" href="classlibdap_1_1Int8.html#a080c4bdb8f6aca03b2ee12f4ba7d6161">libdap::Int8</a>, <a class="el" href="classlibdap_1_1UnMarshaller.html#a997c7de3f371877d20bfeb0b89d1f85e">libdap::UnMarshaller</a>, <a class="el" href="classlibdap_1_1XDRFileMarshaller.html#adec06746eb6502d6166ad96069da0d94">libdap::XDRFileMarshaller</a>, and <a class="el" href="classlibdap_1_1XDRFileUnMarshaller.html#afcd9de045c729321164cba5004746c29">libdap::XDRFileUnMarshaller</a>.</p>

</div>
</div>
<a class="anchor" id="a09a93fbca664f0a060a28f5709c72c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::dump </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumps information about this object </p>
<p>Displays the pointer value of this instance along with information about this cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>C++ i/o stream to dump the information to </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00993">993</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a89b43f4929a90b4708c155257b40fae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::exclusive_to_shared_lock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer from an exclusive lock to a shared lock. If the file has an exclusive write lock on it, change that to a shared read lock. This is an atomic operation. If the call to fcntl(2) is protected by locking the cache, a dead lock will result given typical use of this class. This method exists to help with the situation where one process has the cache locked and is blocking on a shared read lock for a file that a second process has locked exclusively (for writing). By changing the exclusive lock to a shared lock, the first process can get its shared lock and then release the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor that is exclusively locked and which, on exit, will have a shared lock. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00620">620</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3620d839ba6727d0245c61541ef8e6d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::DAPCache3::get_cache_file_name </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mangle</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the name of file that will holds the uncompressed data from 'src' in the cache.</p>
<dl class="section note"><dt>Note</dt><dd>How names are mangled: 'src' is the full name of the file to be cached.Tthe file name passed has an extension on the end that will be stripped once the file is cached. For example, if the full path to the file name is /usr/lib/data/fnoc1.nc.gz then the resulting file name will be #&lt;prefix&gt;#usr#lib#data#fnoc1.nc.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source name to cache </td></tr>
    <tr><td class="paramname">mangle</td><td>if True, assume the name is a file pathname and mangle it. If false, do not mangle the name (assume the caller has sent a suitable string) but do turn the string into a pathname located in the cache directory with the cache prefix. the 'mangle' param is true by default. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00521">521</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a20cccf6a9c84957acf358418f2f920fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long libdap::DAPCache3::get_cache_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache size. Read the size information from the cache info file and return it. This methods locks the cache. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the cache. </dd></dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00772">772</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adfa607870d67dba981060b5fd4b0b768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1DAPCache3.html">DAPCache3</a> * libdap::DAPCache3::get_instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an instance of the <a class="el" href="classlibdap_1_1DAPCache3.html" title="Implementation of a caching mechanism for compressed data. This cache uses simple advisory locking fo...">DAPCache3</a> object. This version is used when there's no question that the cache has been instantiated. </p>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00153">153</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5065a7f6678bdb34ba3e9615e9f5554e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::DAPCache3::get_read_lock </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a read-only lock on the file if it exists. </p>
<p>Try to get a read-only lock on the file, blocking until we can get it. If the file does not exist, return false.</p>
<dl class="section note"><dt>Note</dt><dd>If this code returns false, that means the file did not exist in the cache at the time of the test. by the time the caller gets the result, the file may have been added to the cache by another process.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>src file that will be cached eventually </td></tr>
    <tr><td class="paramname">target</td><td>a value-result parameter set to the resulting cached file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file is in the cache and has been locked, false if the file is/was not in the cache. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>if the attempt to get the (shared) lock failed for any reason other than that the file does/did not exist. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00562">562</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8b68e963914b0fe307a37b86a6986599"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::lock_cache_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a shared lock on the 'cache info' file. </p>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00654">654</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af75c177ee450c8f18e3570c0ebefd8ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::lock_cache_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an exclusive lock on the 'cache info' file. The 'cache info' file is used to control certain cache actions, ensuring that they are atomic. These include making sure that the <a class="el" href="classlibdap_1_1DAPCache3.html#afcf4ad0cb6808bf453a262d29b8f6169" title="Create a file in the cache and lock it for write access. If the file does not exist, make it, open it for read-write access and get an exclusive lock on it. The locking operation blocks, although that should never happen. ">create_and_lock()</a> and read_and_lock() operations are atomic as well as the purge and related operations.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used internally only but might be useful in some settings. </dd></dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00642">642</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a48cd52daa0ae17a1b3abc84473d0e66e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::purge_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge a single file from the cache. </p>
<p>Purge a single file from the cache. The file might be old, etc., and need to be removed. Don't use this to shrink the cache when it gets too big, use <a class="el" href="classlibdap_1_1DAPCache3.html#ae115f42c90bdadc1e6700994c85c9176" title="Purge files from the cache. ">update_and_purge()</a> instead since that file optimizes accesses to the cache control file for several changes in a row.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>This is a new feature; add to BESCache3</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file to purge. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00944">944</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a782bf630f76e5bcab4c356db6101d346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::unlock_and_close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the file. This does not do any name mangling; it just unlocks whatever is named (or throws BESInternalError if the file cannot be closed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The descriptor of the file to unlock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">BESInternalError</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00700">700</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a72f2d56a33176ac93ade3bf16c6c7ec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::unlock_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlock the cache info file.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used internally only bt might be useful in some settings. </dd></dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00668">668</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae115f42c90bdadc1e6700994c85c9176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::DAPCache3::update_and_purge </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>new_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purge files from the cache. </p>
<p>Purge files, oldest to newest, if the current size of the cache exceeds the size of the cache specified in the constructor. This method uses an exclusive lock on the cache for the duration of the purge process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The name of a file this process just added to the cache. Using fcntl(2) locking there is no way this process can detect its own lock, so the shared read lock on the new file won't keep this process from deleting it (but will keep other processes from deleting it). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00854">854</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac3cc2b1e37e3c54080bb38d1abbc3b60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long libdap::DAPCache3::update_cache_info </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the cache info file to include 'target'. </p>
<p>Add the size of the named file to the total cache size recorded in the cache info file. The cache info file is exclusively locked by this method for its duration. This updates the cache info file and returns the new size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new size of the cache </dd></dl>

<p>Definition at line <a class="el" href="DAPCache3_8cc_source.html#l00719">719</a> of file <a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="DAPCache3_8h_source.html">DAPCache3.h</a></li>
<li><a class="el" href="DAPCache3_8cc_source.html">DAPCache3.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1DAPCache3.html">DAPCache3</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
