<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdap: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.20.6</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('todo.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="classfunctions_1_1GeoConstraint.html#a4dcd6ab2bcfe9f1a31cc22d036525e01">functions::GeoConstraint::reorder_data_longitude_axis</a>  (<a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">libdap::Array</a> &amp;a, <a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">libdap::Array::Dim_iter</a> lon_dim)</dt>
<dd>Fix this code so that it works with latitude as the rightmost map  </dd>
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classlibdap_1_1AISResources.html#a35cb470d61a9e94a013520f45514f600">libdap::AISResources::get_resource</a>  (const string &amp;primary)</dt>
<dd>Make this return an empty ResourceVector is no matching resources are found. Clients would not need to call <a class="el" href="classlibdap_1_1AISResources.html#a5db1857c00f33c7962ba02f7ffff08ef">has_resource()</a> which would save some time. </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classlibdap_1_1Array.html#a3c9bb7698219bdcdc4dba1fa38543975">libdap::Array::Array</a>  (const string &amp;n, const string &amp;d, <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> *v, bool is_dap4=false)</dt>
<dd>Force the <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">Array::add_var()</a> method to be used to add <em>v</em>. This version of <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a> calls <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b" title="Add the BaseType pointer to this constructor type instance. ">Vector::add_var()</a>. </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classlibdap_1_1Array.html#ae9a0d029981757fdb6b67c6c020c37e0">libdap::Array::Array</a>  (const string &amp;n, <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> *v, bool is_dap4=false)</dt>
<dd>Force the <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">Array::add_var()</a> method to be used to add <em>v</em>. This version of <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a> calls <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b" title="Add the BaseType pointer to this constructor type instance. ">Vector::add_var()</a>. </dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classlibdap_1_1BaseType.html#adca3c2621c4a509537c18362005d7f7f">libdap::BaseType::add_var</a>  (<a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> *bt, Part part=nil)</dt>
<dd>We should get rid of the Part parameter and adopt the convention that the first variable is the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> and all subsequent ones are Maps (when dealing with a <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>, the only time Part matters). This would enable several methods to migrate from <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> and <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> to <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>. </dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classlibdap_1_1BaseType.html#aadcda7a659157bc6a832d8a5fb775b3f">libdap::BaseType::length</a>  () const</dt>
<dd>change the return type to int64_t  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e">libdap::BaseType::read</a>  ()</dt>
<dd><p class="startdd">Modify the D4 serialize code so that it supports the true/false behavior of <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> for arrays.</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p>Modify all of the stock handlers so they conform to this!</p>
<p class="enddd">Modify all of the stock handlers so they conform to this! </p>
</dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="classlibdap_1_1BaseType.html#a4fe343c1eeb6fb1d61ab030433651d90">libdap::BaseType::set_length</a>  (int)</dt>
<dd>change param type to int64_t  </dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classlibdap_1_1BaseType.html#a4533905a450d2a7af32e7d5acd557676">libdap::BaseType::set_read_p</a>  (bool state)</dt>
<dd>Look at making synthesized variables easier to implement and at making them more integrated into the overall CE evaluation process. Maybe the code that computes the synthesized var's value should be in the that variable's <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method? This might provide a way to get rid of the awkward 'projection functions' by replacing them with real children of <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a>. It would also provide a way to clean up the way the <em>synthesized_p</em> prop intrudes on the <em>read_p</em> prop. </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classlibdap_1_1Constructor.html#af26f89e9c0732a9c32bd5e15d716a7d7">libdap::Constructor::is_linear</a>  ()</dt>
<dd>Change the name to is_flattenable or something like that. 05/16/03 jhrg </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classlibdap_1_1Constructor.html#ab868fe97d5075b702bd084c2e9540913">libdap::Constructor::serialize</a>  (<a class="el" href="classlibdap_1_1D4StreamMarshaller.html" title="Marshaller that knows how to marshal/serialize dap data objects to a C++ iostream using DAP4&#39;s receiv...">D4StreamMarshaller</a> &amp;m, <a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr, bool filter=false)</dt>
<dd>See notebook for 8/21/14 </dd>
<dt><a class="anchor" id="_todo000012"></a>Class <a class="el" href="classlibdap_1_1D4Enum.html">libdap::D4Enum</a>  </dt>
<dd>Note the hack to remove the union...  </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classlibdap_1_1D4Group.html#ab8aa023211f1ed226b73def5e11da787">libdap::D4Group::transform_to_dap2</a>  (<a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> *parent_attr_table)</dt>
<dd>Fix the comment. </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classlibdap_1_1D4RValue.html#adf12fcbb253d9c336527ae12354ae56d">libdap::D4RValue::value</a>  (<a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr)</dt>
<dd>Could move the operation that wraps a constant in a <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> to this method while providing other ways to access the value(s) (methods to determine if the rvalue is a constant and what DAP type it is, e.g.). This would provide an optimization for the filter evaluator which may access the values many times. We might also modify the server side functions so they could access constant values more efficiently. </dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classlibdap_1_1DAPCache3.html#a48cd52daa0ae17a1b3abc84473d0e66e">libdap::DAPCache3::purge_file</a>  (const string &amp;file)</dt>
<dd>This is a new feature; add to BESCache3 </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="classlibdap_1_1DDS.html#a88c063f273e5aa68b38df4d8e09fb426">libdap::DDS::mark</a>  (const string &amp;name, bool state)</dt>
<dd><p class="startdd">These methods that use the btp_stack to keep track of the path from the top of a dataset to a particular variable can be rewritten to use the parent field instead.</p>
<p>All the methods that use names to identify variables should have counterparts that take <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointers. </p>
<p class="enddd">All the methods that use names to identify variables should have counterparts that take <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointers.  </p>
</dd>
<dt><a class="anchor" id="_todo000020"></a>Class <a class="el" href="classlibdap_1_1DODSFilter.html">libdap::DODSFilter</a>  </dt>
<dd><p class="startdd">Add a test to make sure that the required arguments are given. </p>
<p class="enddd">We need to rethink the ancillary file/directory stuff. I don't think it's ever been used... </p>
</dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="classlibdap_1_1DODSFilter.html#aa802f48ceffcaff00634940067a1ba02">libdap::DODSFilter::DODSFilter</a>  ()</dt>
<dd>Add methods to provide a way to set all of the parameters this class contains. They can currently only be set using the argc/argv command line parameters.  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="classlibdap_1_1DODSFilter.html#a75106d93808b268b9f3ef1ac97c5e551">libdap::DODSFilter::establish_timeout</a>  (FILE *stream) const</dt>
<dd>When the alarm handler is called, two CRLF pairs are dumped to the stream and then an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> object is sent. No attempt is made to write the 'correct' MIME headers for an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> object. Instead, a savvy client will know that when an exception is thrown during a deserialize operation, it should scan ahead in the input stream for an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> object. Add this, or a sensible variant once libdap++ supports reliable error delivery. Dumb clients will never get the <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> object...  </dd>
<dt><a class="anchor" id="_todo000022"></a>Class <a class="el" href="classlibdap_1_1fdostream.html">libdap::fdostream</a>  </dt>
<dd>Generalize this so that it can take a FILE * as well and then make two classes file_istream and file_ostream that can be initialized with either a file descriptor or a FILE pointer.  </dd>
<dt><a class="anchor" id="_todo000024"></a>Class <a class="el" href="classlibdap_1_1Grid.html">libdap::Grid</a>  </dt>
<dd><p class="startdd">Move, in some sense, the d_map_vars up to <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>. Look at using <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>'s _var field for these. </p>
<p class="enddd">Along the same lines as the previous item, consider removing the Part enum and adopting the convention that the first variable added is the array and any subsequent variables are maps. </p>
</dd>
<dt><a class="anchor" id="_todo000030"></a>Class <a class="el" href="classlibdap_1_1HTTPCache.html">libdap::HTTPCache</a>  </dt>
<dd><p class="startdd">Update documentation: get_cache_response() now also serves as is_url_in_cache() and <a class="el" href="classlibdap_1_1HTTPCache.html#aa695d43815cc2588458232f37095b780">is_url_valid()</a> should only be called after a locked cached response is accessed using get_cahced_response(). These lock the cache for reading. The methods <a class="el" href="classlibdap_1_1HTTPCache.html#a0cbaded239e55f3e328448adcc180365">cache_response()</a> and <a class="el" href="classlibdap_1_1HTTPCache.html#ab0b1e3fb63084b93e277c53d189ad6c2">update_response()</a> lock an entry for writing.</p>
<p class="enddd">Check that the lock-for-write and lock-for-read work together since it's possible that an entry in use might have a stream of readers and never free the 'read-lock' thus blocking a writer. </p>
</dd>
<dt><a class="anchor" id="_todo000032"></a>Class <a class="el" href="classlibdap_1_1HTTPResponse.html">libdap::HTTPResponse</a>  </dt>
<dd>Maybe refactor so that the header parsing code is here and not in <a class="el" href="classlibdap_1_1HTTPConnect.html">HTTPConnect</a>?  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classlibdap_1_1HTTPResponse.html#a544c05dec998de91e78c9a517041ac3c">libdap::HTTPResponse::HTTPResponse</a>  (std::fstream *s, int status, std::vector&lt; std::string &gt; *h, const std::string &amp;temp_file)</dt>
<dd>Decide on how the temp files fit into DAP4  </dd>
<dt><a class="anchor" id="_todo000034"></a>Class <a class="el" href="classlibdap_1_1Response.html">libdap::Response</a>  </dt>
<dd>If the code that parses the MIME headers was moved from <a class="el" href="classlibdap_1_1Connect.html" title="Holds information about the link from a DAP2 client to a dataset. ">Connect</a> and <a class="el" href="classlibdap_1_1HTTPConnect.html">HTTPConnect</a> to this class and its children, it would be easier to build a FileConnect class (or maybe the specifics of the connection type could be held in the <a class="el" href="classlibdap_1_1Response.html">Response</a> object and <a class="el" href="classlibdap_1_1HTTPConnect.html">HTTPConnect</a> and the to-be-written FileConnect would not be needed).  </dd>
<dt><a class="anchor" id="_todo000036"></a>Class <a class="el" href="classlibdap_1_1Sequence.html">libdap::Sequence</a>  </dt>
<dd>Add an isEmpty() method which returns true if the <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> is empty. This should work before and after calling <a class="el" href="classlibdap_1_1Sequence.html#adf58298f58caf27d467ad41b7ecbb6ec" title="Deserialize (read from the network) the entire Sequence. ">deserialize()</a>. </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classlibdap_1_1Sequence.html#a62d79555aa03b0a862314ccfdad090f8">libdap::Sequence::read_row</a>  (int row, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds, <a class="el" href="classlibdap_1_1ConstraintEvaluator.html" title="Evaluate a constraint expression. ">ConstraintEvaluator</a> &amp;eval, bool ce_eval=true)</dt>
<dd>This code ignores the main reason for nesting the sequences, that if the outer <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a>'s current instance fails the CE, there's no need to look at the values of the inner <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a>. But in the code that calls this method (<a class="el" href="classlibdap_1_1Sequence.html#ad89a496720935e04e472a75ce7804065">serialize()</a> and <a class="el" href="classlibdap_1_1Constructor.html#a822a036364c56df5288a55670f51197e" title="Read data into this variable. ">intern_data()</a>) the CE is not evaluated until the inner-most <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> (i.e., the leaf <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a>) is read. That means that each instance of the inner <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> is read and the CE evaluated for each of those reads. To fix this, and the overall problem of complexity here, we need to re-think Sequences and how they behave. 11/13/2007 jhrg</dd>
</dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
