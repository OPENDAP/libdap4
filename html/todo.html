<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdap: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdap<span id="projectnumber">&#160;Updated for version 3.21.1</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('todo.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Todo List</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="DDS_8cc.html#a6c67a2cfe06f7d2b813fdb3f7955ba8a">c_xml_xsi</a>  </dt>
<dd><a class="anchor" id="_todo000011"></a>Replace all usages of the following variable with calls to DapXmlNamespaces  </dd>
<dt>Member <a class="el" href="classfunctions_1_1GeoConstraint.html#a4dcd6ab2bcfe9f1a31cc22d036525e01">functions::GeoConstraint::reorder_data_longitude_axis</a>  (<a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types.">libdap::Array</a> &amp;a, <a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">libdap::Array::Dim_iter</a> lon_dim)</dt>
<dd><a class="anchor" id="_todo000026"></a>Fix this code so that it works with latitude as the rightmost map  </dd>
<dt>Member <a class="el" href="classlibdap_1_1AISResources.html#a35cb470d61a9e94a013520f45514f600">libdap::AISResources::get_resource</a>  (const string &amp;primary)</dt>
<dd><a class="anchor" id="_todo000001"></a>Make this return an empty <a class="el" href="namespacelibdap.html#a5b62739b998b8aad79bfa8e5eafa3ca2">ResourceVector</a> is no matching resources are found. Clients would not need to call <a class="el" href="classlibdap_1_1AISResources.html#a5db1857c00f33c7962ba02f7ffff08ef">has_resource()</a> which would save some time. </dd>
<dt>Member <a class="el" href="classlibdap_1_1BaseType.html#adca3c2621c4a509537c18362005d7f7f">libdap::BaseType::add_var</a>  (<a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types.">BaseType</a> *bt, <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695" title="Names the parts of multi-section constructor data types.">Part</a> part=nil)</dt>
<dd><a class="anchor" id="_todo000003"></a>We should get rid of the <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695" title="Names the parts of multi-section constructor data types.">Part</a> parameter and adopt the convention that the first variable is the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types.">Array</a> and all subsequent ones are Maps (when dealing with a <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type.">Grid</a>, the only time <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695" title="Names the parts of multi-section constructor data types.">Part</a> matters). This would enable several methods to migrate from <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type.">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a> and <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type.">Grid</a> to <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>. </dd>
<dt>Member <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e">libdap::BaseType::read</a>  ()</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000004"></a>Modify the D4 serialize code so that it supports the true/false behavior of <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer.">read()</a> for arrays.</p>
<p class="enddd"><a class="anchor" id="_todo000005"></a>Modify all of the stock handlers so they conform to this! </p>
</dd>
<dt>Member <a class="el" href="classlibdap_1_1BaseType.html#a4533905a450d2a7af32e7d5acd557676">libdap::BaseType::set_read_p</a>  (bool state)</dt>
<dd><a class="anchor" id="_todo000002"></a>Look at making synthesized variables easier to implement and at making them more integrated into the overall CE evaluation process. Maybe the code that computes the synthesized var's value should be in the that variable's <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer.">read()</a> method? This might provide a way to get rid of the awkward 'projection functions' by replacing them with real children of <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types.">BaseType</a>. It would also provide a way to clean up the way the <em>synthesized_p</em> prop intrudes on the <em>read_p</em> prop. </dd>
<dt>Member <a class="el" href="classlibdap_1_1Constructor.html#a7e2f76dbeb7613aa692844b641dc959f">libdap::Constructor::serialize</a>  (<a class="el" href="classlibdap_1_1D4StreamMarshaller.html" title="Marshaller that knows how to marshal/serialize dap data objects to a C++ iostream using DAP4&#39;s receiv...">D4StreamMarshaller</a> &amp;m, <a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr, bool filter=false) override</dt>
<dd><a class="anchor" id="_todo000006"></a>See notebook for 8/21/14 </dd>
<dt>Class <a class="el" href="classlibdap_1_1D4Enum.html">libdap::D4Enum</a>  </dt>
<dd><a class="anchor" id="_todo000007"></a>Note the hack to remove the union...  </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4Group.html#ae4dd950f803169df67a2aae3d5230c65">libdap::D4Group::transform_to_dap2</a>  (<a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset.">AttrTable</a> *parent_attr_table) override</dt>
<dd><a class="anchor" id="_todo000008"></a>Fix the comment. </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4ResponseBuilder.html#a9fdcdd9829dc56faf3fc4a8ea7bc1df3">libdap::D4ResponseBuilder::establish_timeout</a>  (ostream &amp;stream) const</dt>
<dd><a class="anchor" id="_todo000022"></a>When the alarm handler is called, two CRLF pairs are dumped to the stream and then an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object is sent. Replace this with code that uses the new chunking protocol to insert an error message that can be read.  </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4ResponseBuilder.html#aebf16ce4388f6d30a51c5fdb9c9601d9">libdap::D4ResponseBuilder::read_data_from_cache</a>  (FILE *data, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> *fdds)</dt>
<dd><a class="anchor" id="_todo000025"></a>Maybe move this code into libdap as a general 'get it from disk' method. Use that code in libdapclient. </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4ResponseBuilder.html#ab6e4765d1b870db84d79daf63c70b868">libdap::D4ResponseBuilder::send_data_ddx</a>  (ostream &amp;data_stream, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds, <a class="el" href="classlibdap_1_1ConstraintEvaluator.html" title="Evaluate a constraint expression.">ConstraintEvaluator</a> &amp;eval, const string &amp;start, const string &amp;boundary, bool with_mime_headers=true)</dt>
<dd><a class="anchor" id="_todo000024"></a>I am broken WRT the other code here for sending data and <a class="el" href="classlibdap_1_1DDS.html">DDS</a> responses </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4ResponseBuilder.html#ab77f96539353a88cfdaf24461224c3c6">libdap::D4ResponseBuilder::send_ddx</a>  (ostream &amp;out, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds, <a class="el" href="classlibdap_1_1ConstraintEvaluator.html" title="Evaluate a constraint expression.">ConstraintEvaluator</a> &amp;eval, bool with_mime_headers=true)</dt>
<dd><a class="anchor" id="_todo000023"></a>I am broken WRT the other code here for sending data and <a class="el" href="classlibdap_1_1DDS.html">DDS</a> responses </dd>
<dt>Member <a class="el" href="classlibdap_1_1D4RValue.html#adf12fcbb253d9c336527ae12354ae56d">libdap::D4RValue::value</a>  (<a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr)</dt>
<dd><a class="anchor" id="_todo000009"></a>Could move the operation that wraps a constant in a <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types.">BaseType</a> to this method while providing other ways to access the value(s) (methods to determine if the rvalue is a constant and what DAP type it is, e.g.). This would provide an optimization for the filter evaluator which may access the values many times. We might also modify the server side functions so they could access constant values more efficiently. </dd>
<dt>Member <a class="el" href="classlibdap_1_1DAPCache3.html#a48cd52daa0ae17a1b3abc84473d0e66e">libdap::DAPCache3::purge_file</a>  (const string &amp;file)</dt>
<dd><a class="anchor" id="_todo000010"></a>This is a new feature; add to BESCache3 </dd>
<dt>Member <a class="el" href="classlibdap_1_1DDS.html#a88c063f273e5aa68b38df4d8e09fb426">libdap::DDS::mark</a>  (const string &amp;name, bool state)</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000012"></a>These methods that use the btp_stack to keep track of the path from the top of a dataset to a particular variable can be rewritten to use the parent field instead.</p>
<p class="enddd"><a class="anchor" id="_todo000013"></a>All the methods that use names to identify variables should have counterparts that take <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types.">BaseType</a> pointers.  </p>
</dd>
<dt>Class <a class="el" href="classlibdap_1_1DODSFilter.html">libdap::DODSFilter</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000015"></a>Add a test to make sure that the required arguments are given. </p>
<p class="interdd"></p>
<p class="enddd">We need to rethink the ancillary file/directory stuff. I don't think it's ever been used... </p>
</dd>
<dt>Member <a class="el" href="classlibdap_1_1DODSFilter.html#aa802f48ceffcaff00634940067a1ba02">libdap::DODSFilter::DODSFilter</a>  ()</dt>
<dd><a class="anchor" id="_todo000016"></a>Add methods to provide a way to set all of the parameters this class contains. They can currently only be set using the argc/argv command line parameters.  </dd>
<dt>Member <a class="el" href="classlibdap_1_1DODSFilter.html#a75106d93808b268b9f3ef1ac97c5e551">libdap::DODSFilter::establish_timeout</a>  (FILE *stream) const</dt>
<dd><a class="anchor" id="_todo000014"></a>When the alarm handler is called, two CRLF pairs are dumped to the stream and then an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object is sent. No attempt is made to write the 'correct' MIME headers for an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object. Instead, a savvy client will know that when an exception is thrown during a deserialize operation, it should scan ahead in the input stream for an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object. Add this, or a sensible variant once libdap++ supports reliable error delivery. Dumb clients will never get the <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object...  </dd>
<dt>Class <a class="el" href="classlibdap_1_1fdostream.html">libdap::fdostream</a>  </dt>
<dd><a class="anchor" id="_todo000017"></a>Generalize this so that it can take a FILE * as well and then make two classes file_istream and file_ostream that can be initialized with either a file descriptor or a FILE pointer.  </dd>
<dt>Class <a class="el" href="classlibdap_1_1Grid.html">libdap::Grid</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000018"></a>Move, in some sense, the d_map_vars up to <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>. Look at using <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>'s _var field for these. </p>
<p class="interdd"></p>
<p class="enddd">Along the same lines as the previous item, consider removing the <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695" title="Names the parts of multi-section constructor data types.">Part</a> enum and adopting the convention that the first variable added is the array and any subsequent variables are maps. </p>
</dd>
<dt>Class <a class="el" href="classlibdap_1_1Response.html">libdap::Response</a>  </dt>
<dd><a class="anchor" id="_todo000021"></a>If the code that parses the MIME headers was moved from <a class="el" href="classlibdap_1_1Connect.html" title="Holds information about the link from a DAP2 client to a dataset.">Connect</a> and <a class="el" href="classlibdap_1_1HTTPConnect.html">HTTPConnect</a> to this class and its children, it would be easier to build a FileConnect class (or maybe the specifics of the connection type could be held in the <a class="el" href="classlibdap_1_1Response.html">Response</a> object and <a class="el" href="classlibdap_1_1HTTPConnect.html">HTTPConnect</a> and the to-be-written FileConnect would not be needed).  </dd>
<dt>Class <a class="el" href="classlibdap_1_1Sequence.html">libdap::Sequence</a>  </dt>
<dd><a class="anchor" id="_todo000028"></a>Add an isEmpty() method which returns true if the <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a> is empty. This should work before and after calling <a class="el" href="classlibdap_1_1Sequence.html#adf58298f58caf27d467ad41b7ecbb6ec" title="Deserialize (read from the network) the entire Sequence.">deserialize()</a>. </dd>
<dt>Member <a class="el" href="classlibdap_1_1Sequence.html#a62d79555aa03b0a862314ccfdad090f8">libdap::Sequence::read_row</a>  (int row, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds, <a class="el" href="classlibdap_1_1ConstraintEvaluator.html" title="Evaluate a constraint expression.">ConstraintEvaluator</a> &amp;eval, bool ce_eval=true)</dt>
<dd><a class="anchor" id="_todo000027"></a>This code ignores the main reason for nesting the sequences, that if the outer <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a>'s current instance fails the CE, there's no need to look at the values of the inner <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a>. But in the code that calls this method (<a class="el" href="classlibdap_1_1Sequence.html#ad89a496720935e04e472a75ce7804065">serialize()</a> and <a class="el" href="classlibdap_1_1Constructor.html#a55eaf2a8788e49e8540e1b319f068257" title="Read data into this variable.">intern_data()</a>) the CE is not evaluated until the inner-most <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a> (i.e., the leaf <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a>) is read. That means that each instance of the inner <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence.">Sequence</a> is read and the CE evaluated for each of those reads. To fix this, and the overall problem of complexity here, we need to re-think Sequences and how they behave. 11/13/2007 jhrg</dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
