<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libdap: libdap::Array Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.19.1</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibdap_1_1Array.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibdap_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libdap::Array Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A multidimensional array of identical data types.  
 <a href="classlibdap_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Array_8h_source.html">Array.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libdap::Array:</div>
<div class="dyncontent">
<div class="center"><img src="classlibdap_1_1Array__inherit__graph.png" border="0" usemap="#libdap_1_1Array_inherit__map" alt="Inheritance graph"/></div>
<map name="libdap_1_1Array_inherit__map" id="libdap_1_1Array_inherit__map">
<area shape="rect" id="node2" href="classlibdap_1_1Vector.html" title="Holds a one&#45;dimensional collection of DAP2 data types. " alt="" coords="5,857,181,1521"/>
<area shape="rect" id="node3" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. " alt="" coords="7,145,180,809"/>
<area shape="rect" id="node4" href="classlibdap_1_1DapObj.html" title="libdap base object for common functionality of libdap objects " alt="" coords="38,5,149,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae9c6e71855b90a0e552713011c9ab81f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9c6e71855b90a0e552713011c9ab81f"></a>
typedef stack&lt; <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>btp_stack</b></td></tr>
<tr class="separator:ae9c6e71855b90a0e552713011c9ab81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36e3487697c25295d1b74a346b82720"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#aa36e3487697c25295d1b74a346b82720">Dim_citer</a></td></tr>
<tr class="separator:aa36e3487697c25295d1b74a346b82720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a557c05085a83d1501dbfa249d3cc52"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a></td></tr>
<tr class="separator:a7a557c05085a83d1501dbfa249d3cc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a538f7c336e26b873f50e033d553bba26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a538f7c336e26b873f50e033d553bba26">add_constraint</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, int start, int stride, int stop)</td></tr>
<tr class="memdesc:a538f7c336e26b873f50e033d553bba26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constraint to an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> dimension.  <a href="#a538f7c336e26b873f50e033d553bba26">More...</a><br /></td></tr>
<tr class="separator:a538f7c336e26b873f50e033d553bba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebaff571eb68683238b1afe3063f25d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ebaff571eb68683238b1afe3063f25d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>add_constraint</b> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, <a class="el" href="classlibdap_1_1D4Dimension.html">D4Dimension</a> *dim)</td></tr>
<tr class="separator:a3ebaff571eb68683238b1afe3063f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a68fa480403f9b80285073c653570c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c">add_var</a> (<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *v, <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695">Part</a> p=nil)</td></tr>
<tr class="memdesc:ac9a68fa480403f9b80285073c653570c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer to this constructor type instance.  <a href="#ac9a68fa480403f9b80285073c653570c">More...</a><br /></td></tr>
<tr class="separator:ac9a68fa480403f9b80285073c653570c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41559fa8a060e048f286d7d521fa1a03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41559fa8a060e048f286d7d521fa1a03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_var_nocopy</b> (<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *v, <a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695">Part</a> p=nil)</td></tr>
<tr class="separator:a41559fa8a060e048f286d7d521fa1a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e2d807204976c179ca07e7a3f6f142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a76e2d807204976c179ca07e7a3f6f142">append_dim</a> (int size, const string &amp;<a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a>=&quot;&quot;)</td></tr>
<tr class="memdesc:a76e2d807204976c179ca07e7a3f6f142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a dimension of a given size.  <a href="#a76e2d807204976c179ca07e7a3f6f142">More...</a><br /></td></tr>
<tr class="separator:a76e2d807204976c179ca07e7a3f6f142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fde3d514197a700572e497299b38274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fde3d514197a700572e497299b38274"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>append_dim</b> (<a class="el" href="classlibdap_1_1D4Dimension.html">D4Dimension</a> *dim)</td></tr>
<tr class="separator:a7fde3d514197a700572e497299b38274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a0d029981757fdb6b67c6c020c37e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ae9a0d029981757fdb6b67c6c020c37e0">Array</a> (const string &amp;n, <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *v, bool is_dap4=false)</td></tr>
<tr class="memdesc:ae9a0d029981757fdb6b67c6c020c37e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> constructor.  <a href="#ae9a0d029981757fdb6b67c6c020c37e0">More...</a><br /></td></tr>
<tr class="separator:ae9a0d029981757fdb6b67c6c020c37e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9bb7698219bdcdc4dba1fa38543975"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a3c9bb7698219bdcdc4dba1fa38543975">Array</a> (const string &amp;n, const string &amp;d, <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *v, bool is_dap4=false)</td></tr>
<tr class="memdesc:a3c9bb7698219bdcdc4dba1fa38543975"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> constructor.  <a href="#a3c9bb7698219bdcdc4dba1fa38543975">More...</a><br /></td></tr>
<tr class="separator:a3c9bb7698219bdcdc4dba1fa38543975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893a3fa9df80aae3ec926037fd2debea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a893a3fa9df80aae3ec926037fd2debea">Array</a> (const <a class="el" href="classlibdap_1_1Array.html">Array</a> &amp;rhs)</td></tr>
<tr class="memdesc:a893a3fa9df80aae3ec926037fd2debea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> copy constructor.  <a href="#a893a3fa9df80aae3ec926037fd2debea">More...</a><br /></td></tr>
<tr class="separator:a893a3fa9df80aae3ec926037fd2debea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a56a72c3108b31418ebf01f779253"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#af20a56a72c3108b31418ebf01f779253">buf2val</a> (void **val)</td></tr>
<tr class="separator:af20a56a72c3108b31418ebf01f779253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dcec843f64da6142a7a3208651a5e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#aa2dcec843f64da6142a7a3208651a5e4">check_semantics</a> (string &amp;msg, bool all=false)</td></tr>
<tr class="memdesc:aa2dcec843f64da6142a7a3208651a5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check semantic features of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>.  <a href="#aa2dcec843f64da6142a7a3208651a5e4">More...</a><br /></td></tr>
<tr class="separator:aa2dcec843f64da6142a7a3208651a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9640d5aa2c37123f06220b9c3d77ce82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a9640d5aa2c37123f06220b9c3d77ce82">clear_all_dims</a> ()</td></tr>
<tr class="separator:a9640d5aa2c37123f06220b9c3d77ce82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151f9eaea5f7b22980b1ef86c75723ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a151f9eaea5f7b22980b1ef86c75723ce">clear_constraint</a> ()</td></tr>
<tr class="memdesc:a151f9eaea5f7b22980b1ef86c75723ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the projection; add each projected dimension explicitly using <code>add_constraint</code>.  <a href="#a151f9eaea5f7b22980b1ef86c75723ce">More...</a><br /></td></tr>
<tr class="separator:a151f9eaea5f7b22980b1ef86c75723ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12023f8bf9ecc97998c3bb021ba2772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ac12023f8bf9ecc97998c3bb021ba2772">clear_local_data</a> ()</td></tr>
<tr class="separator:ac12023f8bf9ecc97998c3bb021ba2772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c61fcb646f1813e350549b6ddf48204"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a9c61fcb646f1813e350549b6ddf48204">compute_checksum</a> (<a class="el" href="classCrc32.html">Crc32</a> &amp;checksum)</td></tr>
<tr class="memdesc:a9c61fcb646f1813e350549b6ddf48204"><td class="mdescLeft">&#160;</td><td class="mdescRight">include the data for this variable in the checksum DAP4 includes a checksum with every data response. This method adds the variable's data to that checksum.  <a href="#a9c61fcb646f1813e350549b6ddf48204">More...</a><br /></td></tr>
<tr class="separator:a9c61fcb646f1813e350549b6ddf48204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512a356f31ed6c4c1a368da0b054408a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a512a356f31ed6c4c1a368da0b054408a">d4_ops</a> (<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *b, int op)</td></tr>
<tr class="memdesc:a512a356f31ed6c4c1a368da0b054408a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluator a relop for DAP4.  <a href="#a512a356f31ed6c4c1a368da0b054408a">More...</a><br /></td></tr>
<tr class="separator:a512a356f31ed6c4c1a368da0b054408a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f102f5cc17ac7d2d80f9921e10d3baf"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a9f102f5cc17ac7d2d80f9921e10d3baf">dataset</a> () const </td></tr>
<tr class="memdesc:a9f102f5cc17ac7d2d80f9921e10d3baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the dataset used to create this instance.  <a href="#a9f102f5cc17ac7d2d80f9921e10d3baf">More...</a><br /></td></tr>
<tr class="separator:a9f102f5cc17ac7d2d80f9921e10d3baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86cc0f3915d85e37f4b9e00ebfde7e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#aba86cc0f3915d85e37f4b9e00ebfde7e">deserialize</a> (<a class="el" href="classlibdap_1_1UnMarshaller.html">UnMarshaller</a> &amp;um, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> *dds, bool reuse=false)</td></tr>
<tr class="memdesc:aba86cc0f3915d85e37f4b9e00ebfde7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from the net.  <a href="#aba86cc0f3915d85e37f4b9e00ebfde7e">More...</a><br /></td></tr>
<tr class="separator:aba86cc0f3915d85e37f4b9e00ebfde7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d293754a1d78b90c86f8e33c22bec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ad78d293754a1d78b90c86f8e33c22bec">deserialize</a> (<a class="el" href="classlibdap_1_1D4StreamUnMarshaller.html">D4StreamUnMarshaller</a> &amp;um, <a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr)</td></tr>
<tr class="separator:ad78d293754a1d78b90c86f8e33c22bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e6943cd895fa8dc1c58621ffad42a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ae6e6943cd895fa8dc1c58621ffad42a0">dim_begin</a> ()</td></tr>
<tr class="separator:ae6e6943cd895fa8dc1c58621ffad42a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6b13c4a5d3e825df7ebae3a9dc300d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a1e6b13c4a5d3e825df7ebae3a9dc300d">dim_end</a> ()</td></tr>
<tr class="separator:a1e6b13c4a5d3e825df7ebae3a9dc300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8084269cb03dde18d94377e3c6faf702"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8084269cb03dde18d94377e3c6faf702"></a>
virtual <a class="el" href="classlibdap_1_1D4Dimension.html">D4Dimension</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>dimension_D4dim</b> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i)</td></tr>
<tr class="separator:a8084269cb03dde18d94377e3c6faf702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594eec9c83ef39c93f735e6cc3216c8b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a594eec9c83ef39c93f735e6cc3216c8b">dimension_name</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i)</td></tr>
<tr class="memdesc:a594eec9c83ef39c93f735e6cc3216c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the specified dimension.  <a href="#a594eec9c83ef39c93f735e6cc3216c8b">More...</a><br /></td></tr>
<tr class="separator:a594eec9c83ef39c93f735e6cc3216c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f29497af9c33c0d66939d5f9a16d92a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a8f29497af9c33c0d66939d5f9a16d92a">dimension_size</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, bool constrained=false)</td></tr>
<tr class="memdesc:a8f29497af9c33c0d66939d5f9a16d92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the dimension.  <a href="#a8f29497af9c33c0d66939d5f9a16d92a">More...</a><br /></td></tr>
<tr class="separator:a8f29497af9c33c0d66939d5f9a16d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12084880777d27d782b0e1f2f4d5ae01"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a12084880777d27d782b0e1f2f4d5ae01">dimension_start</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, bool constrained=false)</td></tr>
<tr class="memdesc:a12084880777d27d782b0e1f2f4d5ae01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the start index of a dimension.  <a href="#a12084880777d27d782b0e1f2f4d5ae01">More...</a><br /></td></tr>
<tr class="separator:a12084880777d27d782b0e1f2f4d5ae01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446f239be3ef678a4476058c8041552a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a446f239be3ef678a4476058c8041552a">dimension_stop</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, bool constrained=false)</td></tr>
<tr class="memdesc:a446f239be3ef678a4476058c8041552a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stop index of the constraint.  <a href="#a446f239be3ef678a4476058c8041552a">More...</a><br /></td></tr>
<tr class="separator:a446f239be3ef678a4476058c8041552a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc530e71ace953992a5b314a6f885d31"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#afc530e71ace953992a5b314a6f885d31">dimension_stride</a> (<a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a> i, bool constrained=false)</td></tr>
<tr class="memdesc:afc530e71ace953992a5b314a6f885d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride value of the constraint.  <a href="#afc530e71ace953992a5b314a6f885d31">More...</a><br /></td></tr>
<tr class="separator:afc530e71ace953992a5b314a6f885d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75d1ff3c75b8359d03b3f382bfd179"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#afa75d1ff3c75b8359d03b3f382bfd179">dimensions</a> (bool constrained=false)</td></tr>
<tr class="memdesc:afa75d1ff3c75b8359d03b3f382bfd179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of dimensions in the array.  <a href="#afa75d1ff3c75b8359d03b3f382bfd179">More...</a><br /></td></tr>
<tr class="separator:afa75d1ff3c75b8359d03b3f382bfd179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292d09e6995cbe722e92973c9dc98c7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a292d09e6995cbe722e92973c9dc98c7f">dump</a> (ostream &amp;strm) const </td></tr>
<tr class="memdesc:a292d09e6995cbe722e92973c9dc98c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">dumps information about this object  <a href="#a292d09e6995cbe722e92973c9dc98c7f">More...</a><br /></td></tr>
<tr class="separator:a292d09e6995cbe722e92973c9dc98c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78981c9e05e7d1dc24f913dbd2021d7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ab78981c9e05e7d1dc24f913dbd2021d7">element_count</a> (bool leaves)</td></tr>
<tr class="memdesc:ab78981c9e05e7d1dc24f913dbd2021d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the members of constructor types.  <a href="#ab78981c9e05e7d1dc24f913dbd2021d7">More...</a><br /></td></tr>
<tr class="separator:ab78981c9e05e7d1dc24f913dbd2021d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45c2534829e4e9ef84da32e349e4622"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#ae45c2534829e4e9ef84da32e349e4622">FQN</a> () const </td></tr>
<tr class="separator:ae45c2534829e4e9ef84da32e349e4622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcd9537c67e3bf88964b2656ff5bac1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a1fcd9537c67e3bf88964b2656ff5bac1">get_attr_table</a> ()</td></tr>
<tr class="separator:a1fcd9537c67e3bf88964b2656ff5bac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ee3b0cc0adf6a54ea388ea71a69fc"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a285ee3b0cc0adf6a54ea388ea71a69fc">get_buf</a> ()</td></tr>
<tr class="separator:a285ee3b0cc0adf6a54ea388ea71a69fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d99474ab74d8b9752e4e77b3350121"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ad6d99474ab74d8b9752e4e77b3350121">get_compound_buf</a> ()</td></tr>
<tr class="separator:ad6d99474ab74d8b9752e4e77b3350121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d268981766d84b84ec557d98310ac4a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a3d268981766d84b84ec557d98310ac4a">get_parent</a> () const </td></tr>
<tr class="separator:a3d268981766d84b84ec557d98310ac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53f2eb57de3f0f99961f6ab6f470638"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ab53f2eb57de3f0f99961f6ab6f470638">get_str</a> ()</td></tr>
<tr class="separator:ab53f2eb57de3f0f99961f6ab6f470638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41b7f7790ed80953711e86ffb29c062"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ab41b7f7790ed80953711e86ffb29c062">get_value_capacity</a> () const </td></tr>
<tr class="separator:ab41b7f7790ed80953711e86ffb29c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ee8fec4de3700e2564a64ef4f6d76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a6b5ee8fec4de3700e2564a64ef4f6d76">intern_data</a> (<a class="el" href="classlibdap_1_1ConstraintEvaluator.html">ConstraintEvaluator</a> &amp;eval, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds)</td></tr>
<tr class="memdesc:a6b5ee8fec4de3700e2564a64ef4f6d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">read data into a variable for later use  <a href="#a6b5ee8fec4de3700e2564a64ef4f6d76">More...</a><br /></td></tr>
<tr class="separator:a6b5ee8fec4de3700e2564a64ef4f6d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe772a228c62c7960bf2eb92be77732f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#abe772a228c62c7960bf2eb92be77732f">intern_data</a> ()</td></tr>
<tr class="memdesc:abe772a228c62c7960bf2eb92be77732f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into this variable.  <a href="#abe772a228c62c7960bf2eb92be77732f">More...</a><br /></td></tr>
<tr class="separator:abe772a228c62c7960bf2eb92be77732f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbdef4d63941f6fd53ed444167b89cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#adcbdef4d63941f6fd53ed444167b89cc">is_constructor_type</a> () const </td></tr>
<tr class="memdesc:adcbdef4d63941f6fd53ed444167b89cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instance is a constructor (i.e., <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>) type variable.  <a href="#adcbdef4d63941f6fd53ed444167b89cc">More...</a><br /></td></tr>
<tr class="separator:adcbdef4d63941f6fd53ed444167b89cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac511ec1132a72792050404d235db4ace"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac511ec1132a72792050404d235db4ace"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_dap4</b> () const </td></tr>
<tr class="separator:ac511ec1132a72792050404d235db4ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae302ab2ec26e9fc5b575bf5d3d09aa5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#ae302ab2ec26e9fc5b575bf5d3d09aa5c">is_in_selection</a> ()</td></tr>
<tr class="memdesc:ae302ab2ec26e9fc5b575bf5d3d09aa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this variable part of the current selection?  <a href="#ae302ab2ec26e9fc5b575bf5d3d09aa5c">More...</a><br /></td></tr>
<tr class="separator:ae302ab2ec26e9fc5b575bf5d3d09aa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c0115b16dff66a8e2480c5cff53144"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#ad7c0115b16dff66a8e2480c5cff53144">is_simple_type</a> () const </td></tr>
<tr class="memdesc:ad7c0115b16dff66a8e2480c5cff53144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instance is a numeric, string or URL type variable.  <a href="#ad7c0115b16dff66a8e2480c5cff53144">More...</a><br /></td></tr>
<tr class="separator:ad7c0115b16dff66a8e2480c5cff53144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7ef52b1016703155e920f4be4a537d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a5a7ef52b1016703155e920f4be4a537d">is_vector_type</a> () const </td></tr>
<tr class="memdesc:a5a7ef52b1016703155e920f4be4a537d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the instance is a vector (i.e., array) type variable.  <a href="#a5a7ef52b1016703155e920f4be4a537d">More...</a><br /></td></tr>
<tr class="separator:a5a7ef52b1016703155e920f4be4a537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5990bd42b49e44c7b7da76e039896ba3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a5990bd42b49e44c7b7da76e039896ba3">length</a> () const </td></tr>
<tr class="separator:a5990bd42b49e44c7b7da76e039896ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1d6ce5c4143a9dac90240278c547d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c1d6ce5c4143a9dac90240278c547d1"></a>
virtual <a class="el" href="classlibdap_1_1D4Maps.html">D4Maps</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>maps</b> ()</td></tr>
<tr class="separator:a7c1d6ce5c4143a9dac90240278c547d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0c6b5d57813607dc06255b8e0b9bdc"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a> () const </td></tr>
<tr class="memdesc:a0a0c6b5d57813607dc06255b8e0b9bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the class instance.  <a href="#a0a0c6b5d57813607dc06255b8e0b9bdc">More...</a><br /></td></tr>
<tr class="separator:a0a0c6b5d57813607dc06255b8e0b9bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4c6d411b46e29214c9b19fb7fb28c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc4c6d411b46e29214c9b19fb7fb28c1"></a>
<a class="el" href="classlibdap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlibdap_1_1Array.html">Array</a> &amp;rhs)</td></tr>
<tr class="separator:afc4c6d411b46e29214c9b19fb7fb28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0000be2a244e3e07abda3020af8800"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a8a0000be2a244e3e07abda3020af8800">ops</a> (<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *b, int op)</td></tr>
<tr class="memdesc:a8a0000be2a244e3e07abda3020af8800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate relational operators.  <a href="#a8a0000be2a244e3e07abda3020af8800">More...</a><br /></td></tr>
<tr class="separator:a8a0000be2a244e3e07abda3020af8800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb475b8a855515df7d9ddd254c3f08a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#adcb475b8a855515df7d9ddd254c3f08a">prepend_dim</a> (int size, const string &amp;<a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a>=&quot;&quot;)</td></tr>
<tr class="separator:adcb475b8a855515df7d9ddd254c3f08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cef6fe1d7fe76626f33130380d9752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2cef6fe1d7fe76626f33130380d9752"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepend_dim</b> (<a class="el" href="classlibdap_1_1D4Dimension.html">D4Dimension</a> *dim)</td></tr>
<tr class="separator:ac2cef6fe1d7fe76626f33130380d9752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafb35e8c77673793f2d3897ca1eec4b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#abafb35e8c77673793f2d3897ca1eec4b">print_as_map_xml</a> (ostream &amp;out, string space=&quot;    &quot;, bool constrained=false)</td></tr>
<tr class="separator:abafb35e8c77673793f2d3897ca1eec4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3d7064fae4cfc94d4fc9026fce0667"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a5a3d7064fae4cfc94d4fc9026fce0667">print_as_map_xml</a> (FILE *out, string space=&quot;    &quot;, bool constrained=false)</td></tr>
<tr class="separator:a5a3d7064fae4cfc94d4fc9026fce0667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0077e85bac2620d8746dc50cfd7104ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0077e85bac2620d8746dc50cfd7104ae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>print_as_map_xml_writer</b> (<a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;xml, bool constrained)</td></tr>
<tr class="separator:a0077e85bac2620d8746dc50cfd7104ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976af6f6189ee1f404cd7995df51eabc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a976af6f6189ee1f404cd7995df51eabc">print_dap4</a> (<a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;xml, bool constrained=false)</td></tr>
<tr class="memdesc:a976af6f6189ee1f404cd7995df51eabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the DAP4 representation of an array.  <a href="#a976af6f6189ee1f404cd7995df51eabc">More...</a><br /></td></tr>
<tr class="separator:a976af6f6189ee1f404cd7995df51eabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62456490e14832bd55b9b79d6e37397a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a62456490e14832bd55b9b79d6e37397a">print_decl</a> (ostream &amp;out, string space=&quot;    &quot;, bool print_semi=true, bool constraint_info=false, bool constrained=false)</td></tr>
<tr class="memdesc:a62456490e14832bd55b9b79d6e37397a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a <a class="el" href="classlibdap_1_1DDS.html">DDS</a> entry for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>.  <a href="#a62456490e14832bd55b9b79d6e37397a">More...</a><br /></td></tr>
<tr class="separator:a62456490e14832bd55b9b79d6e37397a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4cee027a63ce185940fd8c019741d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ada4cee027a63ce185940fd8c019741d7">print_decl</a> (FILE *out, string space=&quot;    &quot;, bool print_semi=true, bool constraint_info=false, bool constrained=false)</td></tr>
<tr class="memdesc:ada4cee027a63ce185940fd8c019741d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a <a class="el" href="classlibdap_1_1DDS.html">DDS</a> entry for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>.  <a href="#ada4cee027a63ce185940fd8c019741d7">More...</a><br /></td></tr>
<tr class="separator:ada4cee027a63ce185940fd8c019741d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bdf05ad5a57a517aa6b122b03f06df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#af7bdf05ad5a57a517aa6b122b03f06df">print_val</a> (ostream &amp;out, string space=&quot;&quot;, bool print_decl_p=true)</td></tr>
<tr class="memdesc:af7bdf05ad5a57a517aa6b122b03f06df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the value of the variable.  <a href="#af7bdf05ad5a57a517aa6b122b03f06df">More...</a><br /></td></tr>
<tr class="separator:af7bdf05ad5a57a517aa6b122b03f06df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea9b76dc355fde465f8163d80fafbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#aedea9b76dc355fde465f8163d80fafbb">print_val</a> (FILE *out, string space=&quot;&quot;, bool print_decl_p=true)</td></tr>
<tr class="memdesc:aedea9b76dc355fde465f8163d80fafbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the value of the variable.  <a href="#aedea9b76dc355fde465f8163d80fafbb">More...</a><br /></td></tr>
<tr class="separator:aedea9b76dc355fde465f8163d80fafbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce1bd161426e6950dc97511f33b2845"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a3ce1bd161426e6950dc97511f33b2845">print_xml</a> (ostream &amp;out, string space=&quot;    &quot;, bool constrained=false)</td></tr>
<tr class="separator:a3ce1bd161426e6950dc97511f33b2845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630bb8bac280ba540af9035df5968c2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a630bb8bac280ba540af9035df5968c2b">print_xml</a> (FILE *out, string space=&quot;    &quot;, bool constrained=false)</td></tr>
<tr class="separator:a630bb8bac280ba540af9035df5968c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38718861c5dd21a677746a2211059f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ad38718861c5dd21a677746a2211059f1">print_xml_core</a> (FILE *out, string space, bool constrained, string tag)</td></tr>
<tr class="separator:ad38718861c5dd21a677746a2211059f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29755e9dcff905940b9ee6138ee556be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a29755e9dcff905940b9ee6138ee556be">print_xml_core</a> (ostream &amp;out, string space, bool constrained, string tag)</td></tr>
<tr class="separator:a29755e9dcff905940b9ee6138ee556be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27b27e6edec29098e938bd7bb26d8f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#af27b27e6edec29098e938bd7bb26d8f6">print_xml_writer</a> (<a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;xml, bool constrained=false)</td></tr>
<tr class="separator:af27b27e6edec29098e938bd7bb26d8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0901b2cee44ee6c2ea851822f8f6b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c0901b2cee44ee6c2ea851822f8f6b1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>print_xml_writer_core</b> (<a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;out, bool constrained, string tag)</td></tr>
<tr class="separator:a9c0901b2cee44ee6c2ea851822f8f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deb79c4ebdd6f818558c69bf374f803"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0deb79c4ebdd6f818558c69bf374f803"></a>
virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>prototype</b> () const </td></tr>
<tr class="separator:a0deb79c4ebdd6f818558c69bf374f803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31dc321bd9314239474f30d290e0599a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a31dc321bd9314239474f30d290e0599a">ptr_duplicate</a> ()</td></tr>
<tr class="separator:a31dc321bd9314239474f30d290e0599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da003c53f2e663223f603ab3fbd7c8e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e">read</a> ()</td></tr>
<tr class="memdesc:a1da003c53f2e663223f603ab3fbd7c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a local buffer.  <a href="#a1da003c53f2e663223f603ab3fbd7c8e">More...</a><br /></td></tr>
<tr class="separator:a1da003c53f2e663223f603ab3fbd7c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ff819a432217c55db2e9071928d20c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c">read_p</a> ()</td></tr>
<tr class="memdesc:a38ff819a432217c55db2e9071928d20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has this variable been read?  <a href="#a38ff819a432217c55db2e9071928d20c">More...</a><br /></td></tr>
<tr class="separator:a38ff819a432217c55db2e9071928d20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa7c0f36266ef3df9f4fb90de220867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#aaaa7c0f36266ef3df9f4fb90de220867">reserve_value_capacity</a> (unsigned int numElements)</td></tr>
<tr class="separator:aaaa7c0f36266ef3df9f4fb90de220867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade15ffa55c59f6205e1c3c9ea78a35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#adade15ffa55c59f6205e1c3c9ea78a35">reserve_value_capacity</a> ()</td></tr>
<tr class="separator:adade15ffa55c59f6205e1c3c9ea78a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375d728d50c8b27422c766c84e12300"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ac375d728d50c8b27422c766c84e12300">reset_constraint</a> ()</td></tr>
<tr class="memdesc:ac375d728d50c8b27422c766c84e12300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset constraint to select entire array.  <a href="#ac375d728d50c8b27422c766c84e12300">More...</a><br /></td></tr>
<tr class="separator:ac375d728d50c8b27422c766c84e12300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980c0013817836aa77ef74aeec7fb192"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a980c0013817836aa77ef74aeec7fb192">send_p</a> ()</td></tr>
<tr class="memdesc:a980c0013817836aa77ef74aeec7fb192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should this variable be sent?  <a href="#a980c0013817836aa77ef74aeec7fb192">More...</a><br /></td></tr>
<tr class="separator:a980c0013817836aa77ef74aeec7fb192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993d46232faadb5914cc0519d013e9b2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a993d46232faadb5914cc0519d013e9b2">serialize</a> (<a class="el" href="classlibdap_1_1ConstraintEvaluator.html">ConstraintEvaluator</a> &amp;eval, <a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;dds, <a class="el" href="classlibdap_1_1Marshaller.html">Marshaller</a> &amp;m, bool ce_eval=true)</td></tr>
<tr class="memdesc:a993d46232faadb5914cc0519d013e9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize a <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>.  <a href="#a993d46232faadb5914cc0519d013e9b2">More...</a><br /></td></tr>
<tr class="separator:a993d46232faadb5914cc0519d013e9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af478e3d5cbb3235081fe8daa6d6629a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#af478e3d5cbb3235081fe8daa6d6629a9">serialize</a> (<a class="el" href="classlibdap_1_1D4StreamMarshaller.html">D4StreamMarshaller</a> &amp;m, <a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;dmr, bool filter=false)</td></tr>
<tr class="memdesc:af478e3d5cbb3235081fe8daa6d6629a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The DAP4 serialization method. Serialize a variable's values for DAP4. This does not write the <a class="el" href="classlibdap_1_1DMR.html">DMR</a> persistent representation but does write that part of the binary data blob that holds a variable's data. Once a variable's data are serialized, that memory is reclaimed (by calling <a class="el" href="classlibdap_1_1BaseType.html#aaddb97a4efbe035f41deaf03c6e8683f">BaseType::clear_local_data()</a>)  <a href="#af478e3d5cbb3235081fe8daa6d6629a9">More...</a><br /></td></tr>
<tr class="separator:af478e3d5cbb3235081fe8daa6d6629a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572a1d76a75981abac83a4241e90c0fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a572a1d76a75981abac83a4241e90c0fa">set_attr_table</a> (const <a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> &amp;at)</td></tr>
<tr class="separator:a572a1d76a75981abac83a4241e90c0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc036248cdaf1affac464170f32ad30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a2bc036248cdaf1affac464170f32ad30">set_in_selection</a> (bool state)</td></tr>
<tr class="separator:a2bc036248cdaf1affac464170f32ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca9ddaa9a1ada8447cbe7193e8e288a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abca9ddaa9a1ada8447cbe7193e8e288a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_is_dap4</b> (const bool v)</td></tr>
<tr class="separator:abca9ddaa9a1ada8447cbe7193e8e288a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a61e24fd295934dfc3c37c9f55ca57"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a05a61e24fd295934dfc3c37c9f55ca57">set_length</a> (int l)</td></tr>
<tr class="separator:a05a61e24fd295934dfc3c37c9f55ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfca48c7db65e3a2c3c94734dee8c36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#aacfca48c7db65e3a2c3c94734dee8c36">set_name</a> (const std::string &amp;<a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a>)</td></tr>
<tr class="memdesc:aacfca48c7db65e3a2c3c94734dee8c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the class instance.  <a href="#aacfca48c7db65e3a2c3c94734dee8c36">More...</a><br /></td></tr>
<tr class="separator:aacfca48c7db65e3a2c3c94734dee8c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a39f6ce6594fa74f3fc899ac9a966"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a5b6a39f6ce6594fa74f3fc899ac9a966">set_parent</a> (<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *parent)</td></tr>
<tr class="separator:a5b6a39f6ce6594fa74f3fc899ac9a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58712de8871e28a48fdc95e72a09df71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a58712de8871e28a48fdc95e72a09df71">set_read_p</a> (bool state)</td></tr>
<tr class="memdesc:a58712de8871e28a48fdc95e72a09df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the data is ready to send.  <a href="#a58712de8871e28a48fdc95e72a09df71">More...</a><br /></td></tr>
<tr class="separator:a58712de8871e28a48fdc95e72a09df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64815467570490a4a6cddc89f09a2413"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a64815467570490a4a6cddc89f09a2413">set_send_p</a> (bool state)</td></tr>
<tr class="memdesc:a64815467570490a4a6cddc89f09a2413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the data is ready to send.  <a href="#a64815467570490a4a6cddc89f09a2413">More...</a><br /></td></tr>
<tr class="separator:a64815467570490a4a6cddc89f09a2413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595cb4059cff24f801a1b6da79bd2f9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a595cb4059cff24f801a1b6da79bd2f9e">set_synthesized_p</a> (bool state)</td></tr>
<tr class="separator:a595cb4059cff24f801a1b6da79bd2f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74f8d1ef57c9fcca46f620f75d175a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#af74f8d1ef57c9fcca46f620f75d175a3">set_type</a> (const <a class="el" href="namespacelibdap.html#a05ca706d4539ae7b750c3bc7066ab6e6">Type</a> &amp;t)</td></tr>
<tr class="memdesc:af74f8d1ef57c9fcca46f620f75d175a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of the class instance.  <a href="#af74f8d1ef57c9fcca46f620f75d175a3">More...</a><br /></td></tr>
<tr class="separator:af74f8d1ef57c9fcca46f620f75d175a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559d8ca948ca40f179e4e3da0bfdfdc4"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a559d8ca948ca40f179e4e3da0bfdfdc4">set_value_slice_from_row_major_vector</a> (const <a class="el" href="classlibdap_1_1Vector.html">Vector</a> &amp;rowMajorData, unsigned int startElement)</td></tr>
<tr class="separator:a559d8ca948ca40f179e4e3da0bfdfdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf6e565dcb2eab1f3f7037518a9acb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a8bf6e565dcb2eab1f3f7037518a9acb3">set_vec</a> (unsigned int i, <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *val)</td></tr>
<tr class="memdesc:a8bf6e565dcb2eab1f3f7037518a9acb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element <em>i</em> to value <em>val</em>.  <a href="#a8bf6e565dcb2eab1f3f7037518a9acb3">More...</a><br /></td></tr>
<tr class="separator:a8bf6e565dcb2eab1f3f7037518a9acb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175f1a51686798061c2147f2eccde33a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a175f1a51686798061c2147f2eccde33a">set_vec_nocopy</a> (unsigned int i, <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *val)</td></tr>
<tr class="memdesc:a175f1a51686798061c2147f2eccde33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element <em>i</em> to value <em>val</em>. Set the ith element to val. Extend the vector if needed.  <a href="#a175f1a51686798061c2147f2eccde33a">More...</a><br /></td></tr>
<tr class="separator:a175f1a51686798061c2147f2eccde33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64e677da27249473cdba0b60cdbb90a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#ae64e677da27249473cdba0b60cdbb90a">synthesized_p</a> ()</td></tr>
<tr class="separator:ae64e677da27249473cdba0b60cdbb90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701eb3361f5b5628329ece019cd34519"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a701eb3361f5b5628329ece019cd34519">toString</a> ()</td></tr>
<tr class="separator:a701eb3361f5b5628329ece019cd34519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8e836c622042a339152a6c31e5bdfb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#add8e836c622042a339152a6c31e5bdfb">transfer_attributes</a> (<a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> *at)</td></tr>
<tr class="separator:add8e836c622042a339152a6c31e5bdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc230189460ef65076e8091cf3b6e36"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a1cc230189460ef65076e8091cf3b6e36">transform_to_dap2</a> (<a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> *parent_attr_table)</td></tr>
<tr class="memdesc:a1cc230189460ef65076e8091cf3b6e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms this instance of a D4Array into the corresponding DAP2 object.  <a href="#a1cc230189460ef65076e8091cf3b6e36">More...</a><br /></td></tr>
<tr class="separator:a1cc230189460ef65076e8091cf3b6e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dea8a711559cb0e0b9c36bf41df6473"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a2dea8a711559cb0e0b9c36bf41df6473">transform_to_dap4</a> (<a class="el" href="classlibdap_1_1D4Group.html">D4Group</a> *root, <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a> *container)</td></tr>
<tr class="memdesc:a2dea8a711559cb0e0b9c36bf41df6473"><td class="mdescLeft">&#160;</td><td class="mdescRight">DAP2 to DAP4 transform.  <a href="#a2dea8a711559cb0e0b9c36bf41df6473">More...</a><br /></td></tr>
<tr class="separator:a2dea8a711559cb0e0b9c36bf41df6473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6b2d7099f00bb5f324ec129bff2a17"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibdap.html#a05ca706d4539ae7b750c3bc7066ab6e6">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#abc6b2d7099f00bb5f324ec129bff2a17">type</a> () const </td></tr>
<tr class="memdesc:abc6b2d7099f00bb5f324ec129bff2a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the class instance.  <a href="#abc6b2d7099f00bb5f324ec129bff2a17">More...</a><br /></td></tr>
<tr class="separator:abc6b2d7099f00bb5f324ec129bff2a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4461c9e287b167871acade5e5472116"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#ac4461c9e287b167871acade5e5472116">type_name</a> () const </td></tr>
<tr class="memdesc:ac4461c9e287b167871acade5e5472116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the class instance as a string.  <a href="#ac4461c9e287b167871acade5e5472116">More...</a><br /></td></tr>
<tr class="separator:ac4461c9e287b167871acade5e5472116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4fe08ce144a3fa2d6b15b7ae15ccc0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a4c4fe08ce144a3fa2d6b15b7ae15ccc0">update_length</a> (int size=0)</td></tr>
<tr class="separator:a4c4fe08ce144a3fa2d6b15b7ae15ccc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ecf84f2798065878755d9a9014ee69"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a96ecf84f2798065878755d9a9014ee69">val2buf</a> (void *val, bool reuse=false)</td></tr>
<tr class="memdesc:a96ecf84f2798065878755d9a9014ee69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data into the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> buffer. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if called for <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>. </td></tr>
  </table>
  </dd>
</dl>
 <a href="#a96ecf84f2798065878755d9a9014ee69">More...</a><br /></td></tr>
<tr class="separator:a96ecf84f2798065878755d9a9014ee69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ccb30d1f27ae587f35216b859feec7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#aa5ccb30d1f27ae587f35216b859feec7">var</a> (const string &amp;<a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a>=&quot;&quot;, bool exact_match=true, btp_stack *s=0)</td></tr>
<tr class="separator:aa5ccb30d1f27ae587f35216b859feec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07a950727d2ac58934ba4cc03206c8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ac07a950727d2ac58934ba4cc03206c8d">var</a> (const string &amp;<a class="el" href="classlibdap_1_1BaseType.html#a0a0c6b5d57813607dc06255b8e0b9bdc">name</a>, btp_stack &amp;s)</td></tr>
<tr class="separator:ac07a950727d2ac58934ba4cc03206c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf286762e63295675850c41cedf33370"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#adf286762e63295675850c41cedf33370">var</a> (unsigned int i)</td></tr>
<tr class="separator:adf286762e63295675850c41cedf33370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad180a87244b0b6f32b47711a4ae0330e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ad180a87244b0b6f32b47711a4ae0330e">vec_resize</a> (int l)</td></tr>
<tr class="separator:ad180a87244b0b6f32b47711a4ae0330e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2f0c4e4901b7b98c3178e551edc95e"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a8e2f0c4e4901b7b98c3178e551edc95e">width</a> (bool constrained=false) const </td></tr>
<tr class="memdesc:a8e2f0c4e4901b7b98c3178e551edc95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of the data, in bytes.  <a href="#a8e2f0c4e4901b7b98c3178e551edc95e">More...</a><br /></td></tr>
<tr class="separator:a8e2f0c4e4901b7b98c3178e551edc95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30dc4754b0040a453d00cf5e0b4ddb7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#ad30dc4754b0040a453d00cf5e0b4ddb7">~Array</a> ()</td></tr>
<tr class="memdesc:ad30dc4754b0040a453d00cf5e0b4ddb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> destructor.  <a href="#ad30dc4754b0040a453d00cf5e0b4ddb7">More...</a><br /></td></tr>
<tr class="separator:ad30dc4754b0040a453d00cf5e0b4ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac6ffab2a00584c2963c0d521ad4028b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ffab2a00584c2963c0d521ad4028b5"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_byte *val, int sz)</td></tr>
<tr class="separator:ac6ffab2a00584c2963c0d521ad4028b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c29cba5f93a8571754f2324a6fc170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c29cba5f93a8571754f2324a6fc170"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_int8 *val, int sz)</td></tr>
<tr class="separator:af0c29cba5f93a8571754f2324a6fc170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040fe60aa43a3beecd078c3c7bb4f42f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a040fe60aa43a3beecd078c3c7bb4f42f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_int16 *val, int sz)</td></tr>
<tr class="separator:a040fe60aa43a3beecd078c3c7bb4f42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d2f9bc8fdbb433ddb3d2ceb995ac7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d2f9bc8fdbb433ddb3d2ceb995ac7d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_uint16 *val, int sz)</td></tr>
<tr class="separator:ab6d2f9bc8fdbb433ddb3d2ceb995ac7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c122828120daf1ff5e850e8f7b9ce89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c122828120daf1ff5e850e8f7b9ce89"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_int32 *val, int sz)</td></tr>
<tr class="separator:a8c122828120daf1ff5e850e8f7b9ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565daf922503ff615dac4c6cdb14c1ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a565daf922503ff615dac4c6cdb14c1ea"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_uint32 *val, int sz)</td></tr>
<tr class="separator:a565daf922503ff615dac4c6cdb14c1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af264f7a752cc501bfbccee813733bde3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af264f7a752cc501bfbccee813733bde3"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_int64 *val, int sz)</td></tr>
<tr class="separator:af264f7a752cc501bfbccee813733bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe7846fc2aeb383b9b6263f09c92f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfe7846fc2aeb383b9b6263f09c92f63"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_uint64 *val, int sz)</td></tr>
<tr class="separator:acfe7846fc2aeb383b9b6263f09c92f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba340343eda47f274185ee7a3e6761e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ba340343eda47f274185ee7a3e6761e"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_float32 *val, int sz)</td></tr>
<tr class="separator:a0ba340343eda47f274185ee7a3e6761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d20f40b94b9d901f8124d7d54ed423f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d20f40b94b9d901f8124d7d54ed423f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (dods_float64 *val, int sz)</td></tr>
<tr class="separator:a5d20f40b94b9d901f8124d7d54ed423f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6e429e907214c593b6fb37f97511ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#abd6e429e907214c593b6fb37f97511ee">set_value</a> (string *val, int sz)</td></tr>
<tr class="memdesc:abd6e429e907214c593b6fb37f97511ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the value of a string or url array  <a href="#abd6e429e907214c593b6fb37f97511ee">More...</a><br /></td></tr>
<tr class="separator:abd6e429e907214c593b6fb37f97511ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ba1b5ff3e1283a3ead8e5ef2b3be99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4ba1b5ff3e1283a3ead8e5ef2b3be99"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_byte &gt; &amp;val, int sz)</td></tr>
<tr class="separator:ac4ba1b5ff3e1283a3ead8e5ef2b3be99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e3ce67dddefd2e941833f84d8fb129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e3ce67dddefd2e941833f84d8fb129"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_int8 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a20e3ce67dddefd2e941833f84d8fb129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c39cad25264854e751b67478c36ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c1c39cad25264854e751b67478c36ac"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_int16 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a2c1c39cad25264854e751b67478c36ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e02e571fec26f5ee7e6fe03b9ccf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae18e02e571fec26f5ee7e6fe03b9ccf6"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_uint16 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:ae18e02e571fec26f5ee7e6fe03b9ccf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6479561bdefac3ab843d09fe2a8467c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6479561bdefac3ab843d09fe2a8467c0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_int32 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a6479561bdefac3ab843d09fe2a8467c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73493691f34dc6a871a5557b147ba4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa73493691f34dc6a871a5557b147ba4d"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_uint32 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:aa73493691f34dc6a871a5557b147ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa596cea00692617d5af9cb89eab60c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaa596cea00692617d5af9cb89eab60c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_int64 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:abaa596cea00692617d5af9cb89eab60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18c590ea763d25de3595a7b96cfad2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f18c590ea763d25de3595a7b96cfad2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_uint64 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a1f18c590ea763d25de3595a7b96cfad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d818139d7bd98c4d6e16494e4414ea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d818139d7bd98c4d6e16494e4414ea9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_float32 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a8d818139d7bd98c4d6e16494e4414ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4bfe3aba7506d5e8d3d5182a518359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f4bfe3aba7506d5e8d3d5182a518359"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_value</b> (vector&lt; dods_float64 &gt; &amp;val, int sz)</td></tr>
<tr class="separator:a9f4bfe3aba7506d5e8d3d5182a518359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068afd2353ad32f904361253e1b6e807"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a068afd2353ad32f904361253e1b6e807">set_value</a> (vector&lt; string &gt; &amp;val, int sz)</td></tr>
<tr class="memdesc:a068afd2353ad32f904361253e1b6e807"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the value of a string or url array  <a href="#a068afd2353ad32f904361253e1b6e807">More...</a><br /></td></tr>
<tr class="separator:a068afd2353ad32f904361253e1b6e807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2803db526bd03df4beed106ee7dc6a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2803db526bd03df4beed106ee7dc6a4b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_byte *b) const </td></tr>
<tr class="separator:a2803db526bd03df4beed106ee7dc6a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30687c1e24a09bd00a34fe61466b1a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa30687c1e24a09bd00a34fe61466b1a9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_int8 *b) const </td></tr>
<tr class="separator:aa30687c1e24a09bd00a34fe61466b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419fa012cd8e0d009082365bc83812ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a419fa012cd8e0d009082365bc83812ca"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_int16 *b) const </td></tr>
<tr class="separator:a419fa012cd8e0d009082365bc83812ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8479f83cc14dcd6de7591622eeb86a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf8479f83cc14dcd6de7591622eeb86a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_uint16 *b) const </td></tr>
<tr class="separator:adf8479f83cc14dcd6de7591622eeb86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee04c02a26d6a534dc9c811e638ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcee04c02a26d6a534dc9c811e638ccf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_int32 *b) const </td></tr>
<tr class="separator:adcee04c02a26d6a534dc9c811e638ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d100e18ad454d3ebb4aa0b80fdde7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37d100e18ad454d3ebb4aa0b80fdde7d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_uint32 *b) const </td></tr>
<tr class="separator:a37d100e18ad454d3ebb4aa0b80fdde7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1b7ddbf33836288f9a17756291ef4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1b7ddbf33836288f9a17756291ef4c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_int64 *b) const </td></tr>
<tr class="separator:a1b1b7ddbf33836288f9a17756291ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d60ac7689ede7793191991b7fe97ab8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d60ac7689ede7793191991b7fe97ab8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_uint64 *b) const </td></tr>
<tr class="separator:a5d60ac7689ede7793191991b7fe97ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca52d570c051504ffda7e44f6ae95054"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca52d570c051504ffda7e44f6ae95054"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_float32 *b) const </td></tr>
<tr class="separator:aca52d570c051504ffda7e44f6ae95054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc0f88c2a38b27ecd68c493d055c45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3fc0f88c2a38b27ecd68c493d055c45"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (dods_float64 *b) const </td></tr>
<tr class="separator:af3fc0f88c2a38b27ecd68c493d055c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65aa003dc71e226e137b188213e78eb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a65aa003dc71e226e137b188213e78eb1">value</a> (vector&lt; string &gt; &amp;b) const </td></tr>
<tr class="memdesc:a65aa003dc71e226e137b188213e78eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the data held by this variable.  <a href="#a65aa003dc71e226e137b188213e78eb1">More...</a><br /></td></tr>
<tr class="separator:a65aa003dc71e226e137b188213e78eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c56fb6af6e2d07aa7a4960c36e27f8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c56fb6af6e2d07aa7a4960c36e27f8c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_byte *b) const </td></tr>
<tr class="separator:a9c56fb6af6e2d07aa7a4960c36e27f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc3d7e326bb4be89f4f6040ec1f2bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cc3d7e326bb4be89f4f6040ec1f2bbb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_int8 *b) const </td></tr>
<tr class="separator:a0cc3d7e326bb4be89f4f6040ec1f2bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031197585324cec0eed81b8324607947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a031197585324cec0eed81b8324607947"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_int16 *b) const </td></tr>
<tr class="separator:a031197585324cec0eed81b8324607947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94d5377739c5c5591bc59e7c74f1e30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa94d5377739c5c5591bc59e7c74f1e30"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_uint16 *b) const </td></tr>
<tr class="separator:aa94d5377739c5c5591bc59e7c74f1e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5be821ab4d0a125e1adf026a7bde9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a5be821ab4d0a125e1adf026a7bde9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_int32 *b) const </td></tr>
<tr class="separator:a77a5be821ab4d0a125e1adf026a7bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08a0a76683cd280c79733061d7b0a44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08a0a76683cd280c79733061d7b0a44"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_uint32 *b) const </td></tr>
<tr class="separator:ae08a0a76683cd280c79733061d7b0a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5831136a70de74e97b5a94fb784ee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5831136a70de74e97b5a94fb784ee1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_int64 *b) const </td></tr>
<tr class="separator:abe5831136a70de74e97b5a94fb784ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad657ca4011a3c678bbafa37f2be474f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad657ca4011a3c678bbafa37f2be474f6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_uint64 *b) const </td></tr>
<tr class="separator:ad657ca4011a3c678bbafa37f2be474f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20204ec9548c844a5df2e98d50060b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad20204ec9548c844a5df2e98d50060b4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_float32 *b) const </td></tr>
<tr class="separator:ad20204ec9548c844a5df2e98d50060b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae513021f527ff4137ec579d275bd8b90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae513021f527ff4137ec579d275bd8b90"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (vector&lt; unsigned int &gt; *indices, dods_float64 *b) const </td></tr>
<tr class="separator:ae513021f527ff4137ec579d275bd8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c287b51ec6d033e57c93f4a85f2ae5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a00c287b51ec6d033e57c93f4a85f2ae5">value</a> (vector&lt; unsigned int &gt; *index, vector&lt; string &gt; &amp;b) const </td></tr>
<tr class="memdesc:a00c287b51ec6d033e57c93f4a85f2ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the data held by this variable using the passed subsetIndex vector to identify which values to return.  <a href="#a00c287b51ec6d033e57c93f4a85f2ae5">More...</a><br /></td></tr>
<tr class="separator:a00c287b51ec6d033e57c93f4a85f2ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5000630369cb4217827c2f136afec0"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#aca5000630369cb4217827c2f136afec0">value</a> ()</td></tr>
<tr class="separator:aca5000630369cb4217827c2f136afec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a97452f06d2188eb838399a709246b5e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibdap_1_1D4Attributes.html">D4Attributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a97452f06d2188eb838399a709246b5e9">attributes</a> ()</td></tr>
<tr class="separator:a97452f06d2188eb838399a709246b5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dda4cf43dca838d3de183b8e01cd09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4dda4cf43dca838d3de183b8e01cd09"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_attributes</b> (<a class="el" href="classlibdap_1_1D4Attributes.html">D4Attributes</a> *)</td></tr>
<tr class="separator:ad4dda4cf43dca838d3de183b8e01cd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0e5f87d19020f560d5c1ff8dd4d6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd0e5f87d19020f560d5c1ff8dd4d6a3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_attributes_nocopy</b> (<a class="el" href="classlibdap_1_1D4Attributes.html">D4Attributes</a> *)</td></tr>
<tr class="separator:afd0e5f87d19020f560d5c1ff8dd4d6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a83f21fdd6e522e5ea14aae8682862029"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83f21fdd6e522e5ea14aae8682862029"></a>
<a class="el" href="classlibdap_1_1D4Maps.html">D4Maps</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>d_maps</b></td></tr>
<tr class="separator:a83f21fdd6e522e5ea14aae8682862029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afc1bc92f368ea3a8b136dd751d79752e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc1bc92f368ea3a8b136dd751d79752e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>_duplicate</b> (const <a class="el" href="classlibdap_1_1Array.html">Array</a> &amp;a)</td></tr>
<tr class="separator:afc1bc92f368ea3a8b136dd751d79752e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af175806a557f627a0ee70c5f05ed7c5c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#af175806a557f627a0ee70c5f05ed7c5c">m_create_cardinal_data_buffer_for_type</a> (unsigned int numEltsOfType)</td></tr>
<tr class="separator:af175806a557f627a0ee70c5f05ed7c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e46d6d52fcb609658baf5ac1f9892e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#ad2e46d6d52fcb609658baf5ac1f9892e">m_delete_cardinal_data_buffer</a> ()</td></tr>
<tr class="separator:ad2e46d6d52fcb609658baf5ac1f9892e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffc202435cee93a54af98cd471beb98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acffc202435cee93a54af98cd471beb98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>m_duplicate</b> (const <a class="el" href="classlibdap_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:acffc202435cee93a54af98cd471beb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c55b826c8c5dfe7a454dc670e859a41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1BaseType.html#a0c55b826c8c5dfe7a454dc670e859a41">m_duplicate</a> (const <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> &amp;bt)</td></tr>
<tr class="memdesc:a0c55b826c8c5dfe7a454dc670e859a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a deep copy.  <a href="#a0c55b826c8c5dfe7a454dc670e859a41">More...</a><br /></td></tr>
<tr class="separator:a0c55b826c8c5dfe7a454dc670e859a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe0a4d428323123a49ab39b6d6d8c61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#abfe0a4d428323123a49ab39b6d6d8c61">m_is_cardinal_type</a> () const </td></tr>
<tr class="separator:abfe0a4d428323123a49ab39b6d6d8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb2c5dc539e55203fc61845089c67e8"><td class="memTemplParams" colspan="2">template&lt;class CardType &gt; </td></tr>
<tr class="memitem:a1fb2c5dc539e55203fc61845089c67e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Vector.html#a1fb2c5dc539e55203fc61845089c67e8">m_set_cardinal_values_internal</a> (const CardType *fromArray, int numElts)</td></tr>
<tr class="separator:a1fb2c5dc539e55203fc61845089c67e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435534a45cea53181d30dc09d46734a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a435534a45cea53181d30dc09d46734a7">print_array</a> (FILE *out, unsigned int index, unsigned int dims, unsigned int shape[])</td></tr>
<tr class="memdesc:a435534a45cea53181d30dc09d46734a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the value given the current constraint.  <a href="#a435534a45cea53181d30dc09d46734a7">More...</a><br /></td></tr>
<tr class="separator:a435534a45cea53181d30dc09d46734a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4492771892695010496d2dfb6071e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1Array.html#a88a4492771892695010496d2dfb6071e">print_array</a> (ostream &amp;out, unsigned int index, unsigned int dims, unsigned int shape[])</td></tr>
<tr class="memdesc:a88a4492771892695010496d2dfb6071e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the value given the current constraint.  <a href="#a88a4492771892695010496d2dfb6071e">More...</a><br /></td></tr>
<tr class="separator:a88a4492771892695010496d2dfb6071e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a949a89714965d7afdcd1e3edc8b7f0d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a949a89714965d7afdcd1e3edc8b7f0d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>d_in_selection</b></td></tr>
<tr class="separator:a949a89714965d7afdcd1e3edc8b7f0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629e97e8eb7d285b54c9af8c1ec9a29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a629e97e8eb7d285b54c9af8c1ec9a29a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>d_is_synthesized</b></td></tr>
<tr class="separator:a629e97e8eb7d285b54c9af8c1ec9a29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a76052f084a0023044a84ff5b75a24036"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76052f084a0023044a84ff5b75a24036"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayTest</b></td></tr>
<tr class="separator:a76052f084a0023044a84ff5b75a24036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68515702cd7a6b5b46aa3e00f4e5261b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68515702cd7a6b5b46aa3e00f4e5261b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>D4Group</b></td></tr>
<tr class="separator:a68515702cd7a6b5b46aa3e00f4e5261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A multidimensional array of identical data types. </p>
<p>This class is used to hold arrays of data. The elements of the array can be simple or compound data types. There is no limit on the number of dimensions an array can have, or on the size of each dimension.</p>
<p>If desired, the user can give each dimension of an array a name. You can, for example, have a 360x180 array of temperatures, covering the whole globe with one-degree squares. In this case, you could name the first dimension <em>Longitude</em> and the second dimension <em>Latitude</em>. This can help prevent a great deal of confusion.</p>
<p>The <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is used as part of the <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> class, where the dimension names are crucial to its structure. The dimension names correspond to <em>Map</em> vectors, holding the actual values for that column of the array.</p>
<p>In DAP4, the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> may be a Coverage or a simple <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. In the former case the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> will have both named dimensions and maps, where the maps (instances of <a class="el" href="classlibdap_1_1D4Map.html">D4Map</a>) are what make the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> a Coverage. Coverages are a generalization of DAP2 Grids.</p>
<p>Each array dimension carries with it its own projection information. The projection information takes the form of three integers: the start, stop, and stride values. This is clearest with an example. Consider a one-dimensional array 10 elements long. If the start value of the dimension constraint is 3, then the constrained array appears to be seven elements long. If the stop value is changed to 7, then the array appears to be five elements long. If the stride is changed to two, the array will appear to be 3 elements long. <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> constraints are written as: <b>[start:stride:stop]</b>.</p>
<pre class="fragment">A = [1 2 3 4 5 6 7 8 9 10]

A[3::] = [4 5 6 7 8 9 10]

A[3::7] = [4 5 6 7 8]

A[3:2:7] = [4 6 8]

A[0:3:9] = [1 4 7 10]
</pre><dl class="section note"><dt>Note</dt><dd>Arrays use zero-based indexing. </dd>
<dd>
This class is used for both DAP2 and DAP4.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> </dd>
<dd>
<a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> </dd>
<dd>
<a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a> </dd></dl>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00112">112</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa36e3487697c25295d1b74a346b82720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a>&gt;::const_iterator <a class="el" href="classlibdap_1_1Array.html#aa36e3487697c25295d1b74a346b82720">libdap::Array::Dim_citer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constant iterator used to access the various dimensions of an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Array.html#ae6e6943cd895fa8dc1c58621ffad42a0">dim_begin()</a> </dd>
<dd>
<a class="el" href="classlibdap_1_1Array.html#a1e6b13c4a5d3e825df7ebae3a9dc300d">dim_end()</a> </dd></dl>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00198">198</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7a557c05085a83d1501dbfa249d3cc52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="structlibdap_1_1Array_1_1dimension.html">dimension</a>&gt;::iterator <a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">libdap::Array::Dim_iter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An iterator used to access the various dimensions of an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. Most of the methods that access various properties of a dimension use an instance of Dim_iter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Array.html#ae6e6943cd895fa8dc1c58621ffad42a0">dim_begin()</a> </dd>
<dd>
<a class="el" href="classlibdap_1_1Array.html#a1e6b13c4a5d3e825df7ebae3a9dc300d">dim_end()</a> </dd></dl>

<p>Definition at line <a class="el" href="Array_8h_source.html#l00206">206</a> of file <a class="el" href="Array_8h_source.html">Array.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae9a0d029981757fdb6b67c6c020c37e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libdap::Array::Array </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_dap4</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> constructor. </p>
<p>Build an array with a name and an element type. The name may be omitted, which will create a nameless variable. The template (element type) pointer may also be omitted, but if it is omitted when the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is created, it <em>must</em> be added (with <code><a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a></code>) before <code><a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a></code> or <code><a class="el" href="classlibdap_1_1Vector.html#aba86cc0f3915d85e37f4b9e00ebfde7e" title="Receive data from the net. ">deserialize()</a></code> is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Force the <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">Array::add_var()</a> method to be used to add <em>v</em>. This version of <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a> calls <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b" title="Add the BaseType pointer to this constructor type instance. ">Vector::add_var()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A string containing the name of the variable to be created. </td></tr>
    <tr><td class="paramname">v</td><td>A pointer to a variable of the type to be included in the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. May be null and set later using <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a> or add_var_nocopy() </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00137">137</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3c9bb7698219bdcdc4dba1fa38543975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libdap::Array::Array </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_dap4</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> constructor. </p>
<p>Build an array on the server-side with a name, a dataset name from which this <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is being created, and an element type.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Force the <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">Array::add_var()</a> method to be used to add <em>v</em>. This version of <a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a> calls <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b" title="Add the BaseType pointer to this constructor type instance. ">Vector::add_var()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A string containing the name of the variable to be created. </td></tr>
    <tr><td class="paramname">d</td><td>A string containing the name of the dataset from which this variable is being created. </td></tr>
    <tr><td class="paramname">v</td><td>A pointer to a variable of the type to be included in the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00156">156</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a893a3fa9df80aae3ec926037fd2debea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libdap::Array::Array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> copy constructor. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00163">163</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad30dc4754b0040a453d00cf5e0b4ddb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libdap::Array::~Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> destructor. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00169">169</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a538f7c336e26b873f50e033d553bba26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::add_constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a constraint to an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> dimension. </p>
<p>Once a dimension has been created (see <a class="el" href="classlibdap_1_1Array.html#a76e2d807204976c179ca07e7a3f6f142" title="Add a dimension of a given size. ">append_dim()</a>), it can be constrained. This will make the array appear to the rest of the world to be smaller than it is. This functions sets the projection for a dimension, and marks that dimension as part of the current projection.</p>
<dl class="section note"><dt>Note</dt><dd>A stride value &lt;= 0 or &gt; the array size is an error and causes add_constraint to throw an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a>. Similarly, start or stop values &gt; size also cause an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> exception to be thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>An iterator pointing to the dimension in the list of dimensions. </td></tr>
    <tr><td class="paramname">start</td><td>The start index of the constraint. </td></tr>
    <tr><td class="paramname">stride</td><td>The stride value of the constraint. </td></tr>
    <tr><td class="paramname">stop</td><td>The stop index of the constraint. A value of -1 indicates 'to the end' of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>Thrown if the any of values of start, stop or stride cannot be applied to this array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00648">648</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a68fa480403f9b80285073c653570c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::add_var </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibdap.html#addcb1d714cdecb877c65ff6d2fde0695">Part</a>&#160;</td>
          <td class="paramname"><em>p</em> = <code>nil</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer to this constructor type instance. </p>
<p>Propagate the name of the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> instance to this instance. This ensures that variables at any given level of the <a class="el" href="classlibdap_1_1DDS.html">DDS</a> table have unique names (i.e., that Arrays do not have their default name ""). If <code>v</code>'s name is null, then assume that the array <em>is</em> named and don't overwrite it with <code>v</code>'s null name.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible for the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer to be null when this method is called, a behavior that differs considerably from that of the other '<a class="el" href="classlibdap_1_1Array.html#ac9a68fa480403f9b80285073c653570c" title="Add the BaseType pointer to this constructor type instance. ">add_var()</a>' methods.</dd>
<dd>
This version checks to see if <em>v</em> is an array. If so, it calls <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b" title="Add the BaseType pointer to this constructor type instance. ">Vector::add_var()</a> using the template variable of <em>v</em> and then appends the dimensions of <em>v</em> to this array. This somewhat obscure behavior simplifies 'translating' Sequences to arrays when the actual variable being translated is not a regular <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> but an array of Sequences. This is of very debatable usefulness, but it's here all the same.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The template variable for the array </td></tr>
    <tr><td class="paramname">p</td><td>The Part parameter defaults to nil and is ignored by this method. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1Vector.html#a033417b3c3056fa77f1e32f62a0a2f3b">libdap::Vector</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00480">480</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a76e2d807204976c179ca07e7a3f6f142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::append_dim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a dimension of a given size. </p>
<p>Given a size and a name, this function adds a dimension to the array. For example, if the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is already 10 elements long, calling <code>append_dim</code> with a size of 5 will transform the array into a 10x5 matrix. Calling it again with a size of 2 will create a 10x5x2 array, and so on. This sets <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>'s length member as a side effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the desired new row. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the new dimension. This defaults to an empty string. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00534">534</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a97452f06d2188eb838399a709246b5e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1D4Attributes.html">D4Attributes</a> * libdap::BaseType::attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DAP4 Attribute methods </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00590">590</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af20a56a72c3108b31418ebf01f779253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::buf2val </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies data from the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> buffer. This function assumes that <em>val</em> points to an array large enough to hold N instances of the `C' representation of the <em>numeric</em> element type or C++ string objects. Never call this method for constructor types <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>.</p>
<p>When reading data out of a variable that has been constrained, this method assumes the N values/bytes of constrained data start at the beginning of the object's internal buffer. For example, do not load an entire <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>'s data using <a class="el" href="classlibdap_1_1Vector.html#a96ecf84f2798065878755d9a9014ee69" title="Reads data into the Vector buffer. Thrown if called for Structure, Sequence or Grid. ">val2buf()</a>, constrain and then use this method to get the data. Unless your constraint starts with the [0]th element, the result will not be the correct values.</p>
<p>In the case of a <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> of <a class="el" href="classlibdap_1_1Str.html" title="Holds character string data. ">Str</a> objects, this method will return an array of C++ std::string objects.</p>
<dl class="section note"><dt>Note</dt><dd>It's best to define the pointer to reference the data as 'char *data' and then call this method using '..-&gt;buf2val((void**)&amp;data)'. Then free the storage once you're done using 'delete[] data'. It's not correct C++ to use 'delete[]' on a void pointer and the allocated memory <em>is</em> an array of char, so 'delete[]' is needed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes used to store the array. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A pointer to a pointer to the memory into which the class data will be copied. If the value pointed to is NULL, memory will be allocated to hold the data, and the pointer value modified accordingly. The calling program is responsible for deallocating the memory indicated by this pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if <em>val</em> is null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Vector.html#a8bf6e565dcb2eab1f3f7037518a9acb3" title="Sets element i to value val. ">Vector::set_vec</a> </dd></dl>

<p>Implements <a class="el" href="classlibdap_1_1BaseType.html#accb15b7411e1988ef0a085ebdc88ce5d">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01261">1261</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa2dcec843f64da6142a7a3208651a5e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Array::check_semantics </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check semantic features of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </p>
<p>This function checks semantic features of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. Currently, the only check specific to the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is that there must be dimensions. The rest is inherited from <code><a class="el" href="classlibdap_1_1BaseType.html#aec503abec2fd3090e7738c0a575491f8" title="Compare an object&#39;s current state with the semantics of its type. ">BaseType::check_semantics()</a></code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value. FALSE means there was a problem. </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1Vector.html#afd220155b44708d85d0bb5aa2f756549">libdap::Vector</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01330">1330</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9640d5aa2c37123f06220b9c3d77ce82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::clear_all_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all the dimensions currently set for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. This also removes all constraint information. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00580">580</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a151f9eaea5f7b22980b1ef86c75723ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::clear_constraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the projection; add each projected dimension explicitly using <code>add_constraint</code>. </p>
<p>Tell the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> object to clear the constraint information about dimensions. Do this <em>once</em> before calling <code><a class="el" href="classlibdap_1_1Array.html#a538f7c336e26b873f50e033d553bba26" title="Adds a constraint to an Array dimension. ">add_constraint()</a></code> for each new constraint expression. Only the dimensions explicitly selected using <code><a class="el" href="classlibdap_1_1Array.html#a538f7c336e26b873f50e033d553bba26" title="Adds a constraint to an Array dimension. ">add_constraint()</a></code> will be sent.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This should never be used. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00616">616</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac12023f8bf9ecc97998c3bb021ba2772"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::clear_local_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove any read or set data in the private data of this <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>, setting <a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a> to false. Essentially clears the _buf, d_str, and d_compound_buf of any data. Useful for tightening up memory when the data is no longer needed, but the object cannot yet be destroyed.</p>
<p>On exit: <a class="el" href="classlibdap_1_1Vector.html#ab41b7f7790ed80953711e86ffb29c062">get_value_capacity()</a> == 0 &amp;&amp; !read_p() </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#aaddb97a4efbe035f41deaf03c6e8683f">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01394">1394</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9c61fcb646f1813e350549b6ddf48204"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::compute_checksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCrc32.html">Crc32</a> &amp;&#160;</td>
          <td class="paramname"><em>checksum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>include the data for this variable in the checksum DAP4 includes a checksum with every data response. This method adds the variable's data to that checksum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">checksum</td><td>A <a class="el" href="classCrc32.html">Crc32</a> instance that holds the current checksum. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlibdap_1_1BaseType.html#adacd263e05baa44861eec811037dee05">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00875">875</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a512a356f31ed6c4c1a368da0b054408a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::d4_ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluator a relop for DAP4. </p>
<p>This method is used by the filter expression evaluation code in DAP4. Each of the 'data type' classes that support relops must overload this method. In an expression of the form arg1 op arg2, this object is arg1, the parameter 'b' is arg2 and op is the relational operator.</p>
<dl class="section note"><dt>Note</dt><dd>I used the same relop codes for DAP4 as in the DAP2 parser/scanner which makes for some coupling between them, but cuts way down on the duplication of the evaluator logic, which is somewhat involved.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The second argument in the relational expression </td></tr>
    <tr><td class="paramname">op</td><td>The infix relational operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the expression is true, False otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1Str.html#a051efecca32b2679bd0b1700453db617">libdap::Str</a>, <a class="el" href="classlibdap_1_1Int32.html#ab74be58716d8c3e6d26462dff2a9b565">libdap::Int32</a>, <a class="el" href="classlibdap_1_1Float32.html#a37db8a37ba94af597cd3cfbc6e31f20f">libdap::Float32</a>, <a class="el" href="classlibdap_1_1Byte.html#a44a8efbbd1e0423b4959bc76baf92dfd">libdap::Byte</a>, <a class="el" href="classlibdap_1_1Float64.html#a157203407e1db27b876b9fceacfbf375">libdap::Float64</a>, <a class="el" href="classlibdap_1_1Int16.html#ae02bd87bfcc0479c36c1e6b625e0fcdc">libdap::Int16</a>, <a class="el" href="classlibdap_1_1Int64.html#ac066aff6a587475d50ddd60b3279eb17">libdap::Int64</a>, <a class="el" href="classlibdap_1_1UInt64.html#a1c177d21c0eeeb26083a4cf6a01f7873">libdap::UInt64</a>, and <a class="el" href="classlibdap_1_1Int8.html#aba2aa5b603379c089a2dba07442dfcb9">libdap::Int8</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l01273">1273</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9f102f5cc17ac7d2d80f9921e10d3baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::BaseType::dataset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the dataset used to create this instance. </p>
<p>A dataset from which the data is to be read. The meaning of this string will vary among different types of data sources. It <em>may</em> be the name of a data file or an identifier used to read data from a relational database. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00349">349</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aba86cc0f3915d85e37f4b9e00ebfde7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Vector::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1UnMarshaller.html">UnMarshaller</a> &amp;&#160;</td>
          <td class="paramname"><em>um</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1DDS.html">DDS</a> *&#160;</td>
          <td class="paramname"><em>dds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data from the net. </p>
<p>Receives data from the network connection identified by the <code>source</code> parameter. The data is put into the class data buffer according to the input <code>dds</code>.</p>
<p>This function is only used on the client side of the DODS client/server connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">um</td><td>An <a class="el" href="classlibdap_1_1UnMarshaller.html" title="abstract base class used to unmarshall/deserialize dap data objects ">UnMarshaller</a> that knows how to deserialize data types </td></tr>
    <tr><td class="paramname">dds</td><td>The Data Descriptor <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a> object corresponding to this dataset. See <em>The DODS User Manual</em> for information about this structure. This would have been received from the server in an earlier transmission. </td></tr>
    <tr><td class="paramname">reuse</td><td>A boolean value, indicating whether the class internal data storage can be reused or not. If this argument is TRUE, the class buffer is assumed to be large enough to hold the incoming data, and it is <em>not</em> reallocated. If FALSE, new storage is allocated. If the internal buffer has not been allocated at all, this argument has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns TRUE. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>when a problem reading from the <a class="el" href="classlibdap_1_1UnMarshaller.html" title="abstract base class used to unmarshall/deserialize dap data objects ">UnMarshaller</a> is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1DDS.html">DDS</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a1f27d99250e857efd86ac9db788bbf1b">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00770">770</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad78d293754a1d78b90c86f8e33c22bec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::deserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1D4StreamUnMarshaller.html">D4StreamUnMarshaller</a> &amp;&#160;</td>
          <td class="paramname"><em>um</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;&#160;</td>
          <td class="paramname"><em>dmr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The DAP4 deserialization method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">um</td><td></td></tr>
    <tr><td class="paramname">dmr</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>or <a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a10101e702d03e2a30ebecc341ebc7a08">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01053">1053</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae6e6943cd895fa8dc1c58621ffad42a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Array::Dim_iter</a> libdap::Array::dim_begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the first dimension of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00697">697</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1e6b13c4a5d3e825df7ebae3a9dc300d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Array::Dim_iter</a> libdap::Array::dim_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator past the last dimension of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00704">704</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a594eec9c83ef39c93f735e6cc3216c8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::Array::dimension_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the specified dimension. </p>
<p>This function returns the name of the dimension indicated with <em>p</em>. Since this method is public, it is possible to call it before the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> object has been properly initialized. This will cause an exception. So don't do that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a string containing the dimension name. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00841">841</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8f29497af9c33c0d66939d5f9a16d92a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Array::dimension_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the dimension. </p>
<p>Return the size of the array dimension referred to by <em>i</em>. If the dimension is constrained the constrained size is returned if <em>constrained</em> is <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The dimension.</td></tr>
    <tr><td class="paramname">constrained</td><td>If this parameter is TRUE, the method returns the constrained size of the array so long as a constraint has been applied to this dimension. If TRUE and no constraint has been applied, this method returns zero. If it is FALSE, the method ignores any constraint that has been applied to this dimension and returns the full size of the dimension. The default value is FALSE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer containing the size of the specified dimension. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00743">743</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a12084880777d27d782b0e1f2f4d5ae01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Array::dimension_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the start index of a dimension. </p>
<p>Use this function to return the start index of an array dimension. If the array is constrained (indicated with the <em>constrained</em> argument), the start index of the constrained array is returned (or zero if the dimension in question is not selected at all). See also <code><a class="el" href="classlibdap_1_1Array.html#a446f239be3ef678a4476058c8041552a" title="Return the stop index of the constraint. ">dimension_stop()</a></code> and <code><a class="el" href="classlibdap_1_1Array.html#afc530e71ace953992a5b314a6f885d31" title="Returns the stride value of the constraint. ">dimension_stride()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The dimension. </td></tr>
    <tr><td class="paramname">constrained</td><td>If this parameter is TRUE, the function returns the start index only if the dimension is constrained (subject to a start, stop, or stride constraint). If the dimension is not constrained, the function returns zero. If it is FALSE, the function returns the start index whether or not the dimension is constrained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired start index. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00776">776</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a446f239be3ef678a4476058c8041552a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Array::dimension_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the stop index of the constraint. </p>
<p>Use this function to return the stop index of an array dimension. If the array is constrained (indicated with the <em>constrained</em> argument), the stop index of the constrained array is returned (or zero if the dimension in question is not selected at all). See also <code><a class="el" href="classlibdap_1_1Array.html#a12084880777d27d782b0e1f2f4d5ae01" title="Return the start index of a dimension. ">dimension_start()</a></code> and <code><a class="el" href="classlibdap_1_1Array.html#afc530e71ace953992a5b314a6f885d31" title="Returns the stride value of the constraint. ">dimension_stride()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The dimension. </td></tr>
    <tr><td class="paramname">constrained</td><td>If this parameter is TRUE, the function returns the stop index only if the dimension is constrained (subject to a start, stop, or stride constraint). If the dimension is not constrained, the function returns zero. If it is FALSE, the function returns the stop index whether or not the dimension is constrained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The desired stop index. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00800">800</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afc530e71ace953992a5b314a6f885d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Array::dimension_stride </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Array.html#a7a557c05085a83d1501dbfa249d3cc52">Dim_iter</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stride value of the constraint. </p>
<p>Use this function to return the stride value of an array dimension. If the array is constrained (indicated with the <em>constrained</em> argument), the stride value of the constrained array is returned (or zero if the dimension in question is not selected at all). See also <code><a class="el" href="classlibdap_1_1Array.html#a446f239be3ef678a4476058c8041552a" title="Return the stop index of the constraint. ">dimension_stop()</a></code> and <code><a class="el" href="classlibdap_1_1Array.html#a12084880777d27d782b0e1f2f4d5ae01" title="Return the start index of a dimension. ">dimension_start()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The dimension. </td></tr>
    <tr><td class="paramname">constrained</td><td>If this parameter is TRUE, the function returns the stride value only if the dimension is constrained (subject to a start, stop, or stride constraint). If the dimension is not constrained, the function returns zero. If it is FALSE, the function returns the stride value whether or not the dimension is constrained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The stride value requested, or zero, if <em>constrained</em> is TRUE and the dimension is not selected. </dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00825">825</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afa75d1ff3c75b8359d03b3f382bfd179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Array::dimensions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of dimensions in the array. </p>
<p>Return the total number of dimensions contained in the array. When <em>constrained</em> is TRUE, return the number of dimensions given the most recently evaluated constraint expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constrained</td><td>A boolean flag to indicate whether the array is constrained or not. Ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00720">720</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a292d09e6995cbe722e92973c9dc98c7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::dump </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>strm</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dumps information about this object </p>
<p>Displays the pointer value of this instance and information about this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>C++ i/o stream to dump the information to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1Vector.html#a719617cae1386c64723abf845651ed4d">libdap::Vector</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01349">1349</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab78981c9e05e7d1dc24f913dbd2021d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Vector::element_count </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leaves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the members of constructor types. </p>
<p>Return a count of the total number of variables in this variable. This is used to count the number of variables held by a constructor variable - for simple type and vector variables it always returns 1.</p>
<p>For compound data types, there are two ways to count members. You can count the members, or you can count the simple members and add that to the count of the compound members. For example, if a <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a> contains an <a class="el" href="classlibdap_1_1Int32.html" title="Holds a 32-bit signed integer. ">Int32</a> and another <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a> that itself contains two <a class="el" href="classlibdap_1_1Int32.html" title="Holds a 32-bit signed integer. ">Int32</a> members, the element count of the top-level structure could be two (one <a class="el" href="classlibdap_1_1Int32.html" title="Holds a 32-bit signed integer. ">Int32</a> and one <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>) or three (one <a class="el" href="classlibdap_1_1Int32.html" title="Holds a 32-bit signed integer. ">Int32</a> by itself and two <a class="el" href="classlibdap_1_1Int32.html" title="Holds a 32-bit signed integer. ">Int32</a>'s in the subsidiary <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>). Use the <em>leaves</em> parameter to control which kind of counting you desire.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 for simple types. For compound members, the count depends on the <em>leaves</em> argument. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">leaves</td><td>This parameter is only relevant if the object contains other compound data types. If FALSE, the function counts only the data variables mentioned in the object's declaration. If TRUE, it counts the simple members, and adds that to the sum of the counts for the compound members. This parameter has no effect for simple type variables. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a5c2235737737b482bfa7536b8aeab810">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00334">334</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae45c2534829e4e9ef84da32e349e4622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::BaseType::FQN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the FQN for this variable. This will include the D4 Group component of the name.</p>
<dl class="section return"><dt>Returns</dt><dd>The FQN in a string </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1D4Group.html#a88e7d55deb65ba9ef5ae8abf8397d327">libdap::D4Group</a>, and <a class="el" href="classlibdap_1_1Constructor.html#a8063acc5c31fc265f38ba3ed7d2e7e17">libdap::Constructor</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00323">323</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1fcd9537c67e3bf88964b2656ff5bac1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> &amp; libdap::BaseType::get_attr_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get this variable's <a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a>. It's generally a bad idea to return a reference to a contained object, but in this case it seems that building an interface inside <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> is overkill.</p>
<p>Use the <a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> methods to manipulate the table. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00573">573</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a285ee3b0cc0adf6a54ea388ea71a69fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* libdap::Vector::get_buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide access to internal data by reference. Callers cannot delete this but can pass them to other methods.</p>
<dl class="section note"><dt>Note</dt><dd>Added so that the NCML handler can code some optimizations in its specialized versions of <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. jhrg 8/14/15 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the data buffer for Vectors/Arrays of the cardinal types. </dd></dl>

<p>Definition at line <a class="el" href="Vector_8h_source.html#l00138">138</a> of file <a class="el" href="Vector_8h_source.html">Vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad6d99474ab74d8b9752e4e77b3350121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classlibdap_1_1BaseType.html">BaseType</a>*&gt;&amp; libdap::Vector::get_compound_buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide access to internal data by reference. Callers cannot delete this but can pass them to other methods.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to a vector of <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointers. Treat with care; never delete these! </dd></dl>

<p>Definition at line <a class="el" href="Vector_8h_source.html#l00159">159</a> of file <a class="el" href="Vector_8h_source.html">Vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d268981766d84b84ec557d98310ac4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * libdap::BaseType::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a> or <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> which holds (contains) this variable. If this variable is at the top level, this method returns null.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer to the variable's parent. </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00742">742</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab53f2eb57de3f0f99961f6ab6f470638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt;&amp; libdap::Vector::get_str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide access to internal string data by reference. Callers cannot delete this but can pass them to other methods.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to a vector of strings </dd></dl>

<p>Definition at line <a class="el" href="Vector_8h_source.html#l00148">148</a> of file <a class="el" href="Vector_8h_source.html">Vector.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab41b7f7790ed80953711e86ffb29c062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::get_value_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the capacity of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> in terms of number of elements of its data type that it can currently hold (i.e. not bytes). For example, this could be the size of the _buf array in bytes / sizeof(T) for the cardinal types T, or the capacity of the d_str vector if T is string or url type. </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01421">1421</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6b5ee8fec4de3700e2564a64ef4f6d76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::intern_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1ConstraintEvaluator.html">ConstraintEvaluator</a> &amp;&#160;</td>
          <td class="paramname"><em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;&#160;</td>
          <td class="paramname"><em>dds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read data into a variable for later use </p>
<p>Most uses of a variable are to either serialize its data to a stream of some sort or to read values from some stream and intern those in the variable for later use. These operations are perform by <a class="el" href="classlibdap_1_1Vector.html#a993d46232faadb5914cc0519d013e9b2" title="Serialize a Vector. ">serialize()</a> and <a class="el" href="classlibdap_1_1Vector.html#aba86cc0f3915d85e37f4b9e00ebfde7e" title="Receive data from the net. ">deserialize()</a> which follow. This function performs essentially both of these operations without actually using a stream device. The data are read using the <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method(s) and loaded into the variables directly.</p>
<p>This method is intended to be used by objects which transform DAP objects like the <a class="el" href="classlibdap_1_1DataDDS.html" title="Holds a DAP2 DDS. ">DataDDS</a> into an ASCII CSV representation.</p>
<dl class="section note"><dt>Note</dt><dd>A DAP2-only method</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval</td><td>A reference to a constraint evaluator </td></tr>
    <tr><td class="paramname">dds</td><td>The complete <a class="el" href="classlibdap_1_1DDS.html">DDS</a> to which this variable belongs </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a722d33783aa0272d339b0301a4f77e59">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00604">604</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abe772a228c62c7960bf2eb92be77732f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::intern_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into this variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eval</td><td>Evaluator for a constraint expression </td></tr>
    <tr><td class="paramname">dmr</td><td><a class="el" href="classlibdap_1_1DMR.html">DMR</a> for the whole dataset </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a1956e6ea90a745516f5372c859173433">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00918">918</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adcbdef4d63941f6fd53ed444167b89cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::is_constructor_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instance is a constructor (i.e., <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>) type variable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the instance is a <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>, False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00403">403</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae302ab2ec26e9fc5b575bf5d3d09aa5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::is_in_selection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this variable part of the current selection? </p>
<p>Does this variable appear in either the selection part or as a function argument in the current constrain expression. If this property is set (true) then implementations of the <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method should read this variable.</p>
<dl class="section note"><dt>Note</dt><dd>This method does not check, nor does it know about the semantics of, string arguments passed to functions. Those functions might include variable names in strings; they are responsible for reading those variables. See the grid (func_grid_select()) for an example. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">BaseType::read()</a> </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00694">694</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad7c0115b16dff66a8e2480c5cff53144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::is_simple_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instance is a numeric, string or URL type variable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the instance is a scalar numeric, String or URL variable, False otherwise. Arrays (even of simple types) return False. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#a5a7ef52b1016703155e920f4be4a537d" title="Returns true if the instance is a vector (i.e., array) type variable. ">is_vector_type()</a> </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00384">384</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5a7ef52b1016703155e920f4be4a537d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::is_vector_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the instance is a vector (i.e., array) type variable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the instance is an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>, False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00393">393</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5990bd42b49e44c7b7da76e039896ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::Vector::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of elements in the vector. Note that some child classes of <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> use the length of -1 as a flag value.</p>
<dl class="section see"><dt>See also</dt><dd>Vector::append_dim </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a2176cb199d136fedb1eb9070fb9dcf4b">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00555">555</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af175806a557f627a0ee70c5f05ed7c5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::m_create_cardinal_data_buffer_for_type </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numEltsOfType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create _buf so that it can store numElts of the (assumed) cardinal type. This create storage for <a class="el" href="classlibdap_1_1Vector.html#a8e2f0c4e4901b7b98c3178e551edc95e" title="Returns the width of the data, in bytes. ">width()</a> * numElts bytes. If _buf already exists, this DELETES IT and creates a new one. So don't use this if you want to keep the original _buf data around. This also sets the valueCapacity(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numEltsOfType</td><td>the number of elements of the cardinal type in <a class="el" href="classlibdap_1_1Vector.html#aa5ccb30d1f27ae587f35216b859feec7">var()</a> that we want storage for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the buffer created. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>'s type is not cardinal type. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00181">181</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e46d6d52fcb609658baf5ac1f9892e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::m_delete_cardinal_data_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete d_buf and zero it and d_capacity out </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00209">209</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0c55b826c8c5dfe7a454dc670e859a41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::m_duplicate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> &amp;&#160;</td>
          <td class="paramname"><em>bt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a deep copy. </p>
<p>Perform a deep copy. Copies the values of <em>bt</em> into <code>*this</code>. Pointers are dereferenced and their values are copied into a newly allocated instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bt</td><td>The source object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00085">85</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abfe0a4d428323123a49ab39b6d6d8c61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Vector::m_is_cardinal_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether the type of this <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> is a cardinal type (i.e., stored in d_buf) </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00124">124</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1fb2c5dc539e55203fc61845089c67e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CardType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::m_set_cardinal_values_internal </td>
          <td>(</td>
          <td class="paramtype">const CardType *&#160;</td>
          <td class="paramname"><em>fromArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numElts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to reduce cut and paste in the virtual's. </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00220">220</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0a0c6b5d57813607dc06255b8e0b9bdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::BaseType::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the class instance. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00311">311</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8a0000be2a244e3e07abda3020af8800"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::ops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate relational operators. </p>
<p>This method contains the relational operators used by the constraint expression evaluator in the <a class="el" href="classlibdap_1_1DDS.html">DDS</a> class. Each class that wants to be able to evaluate relational expressions must overload this function. The implementation in <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> throws an <a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a> exception. The DAP library classes <a class="el" href="classlibdap_1_1Byte.html" title="Holds a single byte. ">Byte</a>, ..., <a class="el" href="classlibdap_1_1Url.html" title="Holds an Internet address (URL). ">Url</a> provide specializations of this method. It is not meaningful for classes such as <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> because relational expressions using <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> are not supported.</p>
<p>The <em>op</em> argument refers to a table generated by bison from the constraint expression parser. Use statements like the following to correctly interpret its value:</p>
<pre class="fragment">switch (op) {
    case EQUAL: return i1 == i2;
    case NOT_EQUAL: return i1 != i2;
    case GREATER: return i1 &gt; i2;
    case GREATER_EQL: return i1 &gt;= i2;
    case LESS: return i1 &lt; i2;
    case LESS_EQL: return i1 &lt;= i2;
    case REGEXP: throw Error("Regular expressions are not supported for integer values");
    default: throw Error("Unknown operator");
}
</pre><p>This function is used by the constraint expression evaluator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Compare the value of this instance with <em>b</em>. </td></tr>
    <tr><td class="paramname">op</td><td>An integer index indicating which relational operator is implied. Choose one from the following: <code>EQUAL</code>, <code>NOT_EQUAL</code>, <code>GREATER</code>, <code>GREATER_EQL</code>, <code>LESS</code>, <code>LESS_EQL</code>, and <code>REGEXP</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean value of the comparison. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#a512a356f31ed6c4c1a368da0b054408a" title="Evaluator a relop for DAP4. ">BaseType::d4_ops(BaseType *, int)</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1D4Enum.html#a300dfa8bd3ce44b3e2123397ac8c6415">libdap::D4Enum</a>, <a class="el" href="classlibdap_1_1Str.html#a5b74994fb52ceb3248c558015c4520a5">libdap::Str</a>, <a class="el" href="classlibdap_1_1Int32.html#ac319d1cdae57d4fc7bfbd972f2f8d4a1">libdap::Int32</a>, <a class="el" href="classlibdap_1_1Float32.html#accebf037e94f4e455cce505295c4cb0a">libdap::Float32</a>, <a class="el" href="classlibdap_1_1Byte.html#ad97b380875f85f6e7c3d02488f209afa">libdap::Byte</a>, <a class="el" href="classlibdap_1_1Float64.html#a32114121abfd8b081b4834fb87dc19ac">libdap::Float64</a>, <a class="el" href="classlibdap_1_1UInt32.html#a33a7ffcc50faa13ed94a48e7766ffd1e">libdap::UInt32</a>, <a class="el" href="classlibdap_1_1D4Opaque.html#aedf47172b055ecbe59363808903b5f94">libdap::D4Opaque</a>, <a class="el" href="classlibdap_1_1Int16.html#ad72c7db64b35bf1e8ad8aa7e27526cb9">libdap::Int16</a>, <a class="el" href="classlibdap_1_1UInt16.html#a0f82046f304407cb218bfbe88e89518b">libdap::UInt16</a>, <a class="el" href="classlibdap_1_1Int64.html#a80a9bdafa15ee063ad3d387cffe36cf1">libdap::Int64</a>, <a class="el" href="classlibdap_1_1UInt64.html#a4ceb6fa4a9fc731410962dc9e1c787a4">libdap::UInt64</a>, and <a class="el" href="classlibdap_1_1Int8.html#a2d63b4ba6571ce6d2c673fe7f9adb59a">libdap::Int8</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l01247">1247</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adcb475b8a855515df7d9ddd254c3f08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::prepend_dim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new OUTER dimension (slowest varying in rowmajor) for the array by prepending rather than appending it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>cardinality of the new dimension </td></tr>
    <tr><td class="paramname">name</td><td>optional name for the new dimension </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00557">557</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a435534a45cea53181d30dc09d46734a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Array::print_array </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>shape</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the value given the current constraint. </p>
<p>Prints the values in ASCII of the entire (constrained) array. This method Attempts to make an aesthetically pleasing display. However, it is primarily intended for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Write the output to this FILE *. </td></tr>
    <tr><td class="paramname">index</td><td></td></tr>
    <tr><td class="paramname">dims</td><td></td></tr>
    <tr><td class="paramname">shape</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01217">1217</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a88a4492771892695010496d2dfb6071e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Array::print_array </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>shape</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the value given the current constraint. </p>
<p>Prints the values in ASCII of the entire (constrained) array. This method Attempts to make an anesthetically pleasing display. However, it is primarily intended for debugging purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Write the output to this ostream </td></tr>
    <tr><td class="paramname">index</td><td></td></tr>
    <tr><td class="paramname">dims</td><td></td></tr>
    <tr><td class="paramname">shape</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01238">1238</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abafb35e8c77673793f2d3897ca1eec4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_as_map_xml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01111">1111</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5a3d7064fae4cfc94d4fc9026fce0667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_as_map_xml </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01100">1100</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a976af6f6189ee1f404cd7995df51eabc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_dap4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the DAP4 representation of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xml</td><td></td></tr>
    <tr><td class="paramname">constrained</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#afcddbe441380b95c894510c02980b163">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00966">966</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a62456490e14832bd55b9b79d6e37397a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_decl </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_semi</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constraint_info</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a <a class="el" href="classlibdap_1_1DDS.html">DDS</a> entry for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </p>
<p>Prints a declaration for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. This is what appears in a <a class="el" href="classlibdap_1_1DDS.html">DDS</a>. If the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is constrained, the declaration will reflect the size of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> once the constraint is applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Write the output to this ostream. </td></tr>
    <tr><td class="paramname">space</td><td>A string containing spaces to precede the declaration. </td></tr>
    <tr><td class="paramname">print_semi</td><td>A boolean indicating whether to print a semi-colon after the declaration. (TRUE means ``print a semi-colon.'') </td></tr>
    <tr><td class="paramname">constraint_info</td><td>A boolean value. See <code><a class="el" href="classlibdap_1_1BaseType.html#a2d799fad93255d7f2b803562ae7a5784" title="Print an ASCII representation of the variable structure. ">BaseType::print_decl()</a></code>. </td></tr>
    <tr><td class="paramname">constrained</td><td>This argument should be TRUE if the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is constrained, and FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#afd744b0ddeb04e7b173c9e83423ec572">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01049">1049</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ada4cee027a63ce185940fd8c019741d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_decl </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_semi</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constraint_info</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints a <a class="el" href="classlibdap_1_1DDS.html">DDS</a> entry for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. </p>
<p>Prints a declaration for the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>. This is what appears in a <a class="el" href="classlibdap_1_1DDS.html">DDS</a>. If the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is constrained, the declaration will reflect the size of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> once the constraint is applied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Write the output to this FILE *. </td></tr>
    <tr><td class="paramname">space</td><td>A string containing spaces to precede the declaration. </td></tr>
    <tr><td class="paramname">print_semi</td><td>A boolean indicating whether to print a semi-colon after the declaration. (TRUE means ``print a semi-colon.'') </td></tr>
    <tr><td class="paramname">constraint_info</td><td>A boolean value. See <code><a class="el" href="classlibdap_1_1BaseType.html#a2d799fad93255d7f2b803562ae7a5784" title="Print an ASCII representation of the variable structure. ">BaseType::print_decl()</a></code>. </td></tr>
    <tr><td class="paramname">constrained</td><td>This argument should be TRUE if the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is constrained, and FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a2d799fad93255d7f2b803562ae7a5784">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01024">1024</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af7bdf05ad5a57a517aa6b122b03f06df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_val </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_decl_p</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the value of the variable. </p>
<p>Prints the value of the variable, with its declaration. This function is primarily intended for debugging DODS applications. However, it can be overloaded and used to do some useful things. Take a look at the asciival and writeval clients, both of which overload this to output the values of variables in different ways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output ostream on which to print the value. </td></tr>
    <tr><td class="paramname">space</td><td>This value is passed to the <a class="el" href="classlibdap_1_1Array.html#a62456490e14832bd55b9b79d6e37397a" title="Prints a DDS entry for the Array. ">print_decl()</a> function, and controls the leading spaces of the output. </td></tr>
    <tr><td class="paramname">print_decl_p</td><td>A boolean value controlling whether the variable declaration is printed as well as the value. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlibdap_1_1BaseType.html#a94edd5b610afb1432144158740710488">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01293">1293</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aedea9b76dc355fde465f8163d80fafbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_val </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_decl_p</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints the value of the variable. </p>
<p>Prints the value of the variable, with its declaration. This function is primarily intended for debugging DODS applications. However, it can be overloaded and used to do some useful things. Take a look at the asciival and writeval clients, both of which overload this to output the values of variables in different ways.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream on which to print the value. </td></tr>
    <tr><td class="paramname">space</td><td>This value is passed to the <a class="el" href="classlibdap_1_1Array.html#a62456490e14832bd55b9b79d6e37397a" title="Prints a DDS entry for the Array. ">print_decl()</a> function, and controls the leading spaces of the output. </td></tr>
    <tr><td class="paramname">print_decl_p</td><td>A boolean value controlling whether the variable declaration is printed as well as the value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#afb5e13838a599ec0efe2adbb2ae18f47">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01285">1285</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce1bd161426e6950dc97511f33b2845"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_xml </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a8bd2c7682edd48c64b210bdf247bdef7">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01089">1089</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a630bb8bac280ba540af9035df5968c2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_xml </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd></dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a825820edee179550cfde3dfd4d274f2a">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01078">1078</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad38718861c5dd21a677746a2211059f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_xml_core </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01122">1122</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a29755e9dcff905940b9ee6138ee556be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_xml_core </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd></dd></dl>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01133">1133</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af27b27e6edec29098e938bd7bb26d8f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::print_xml_writer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1XMLWriter.html">XMLWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>xml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the XML representation of this variable. This method is used to build the DDX XML response. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Destination output stream </td></tr>
    <tr><td class="paramname">space</td><td>Use this to indent child declarations. Default is "". </td></tr>
    <tr><td class="paramname">constrained</td><td>If true, only print this if it's part part of the current projection. Default is False. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a11554ff931528b243e9af8173d205b44">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l01141">1141</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a31dc321bd9314239474f30d290e0599a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * libdap::Array::ptr_duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone this instance. Allocate a new instance and copy <code>*this</code> into it. This method must perform a deep copy. </p><pre class="fragment">@note This method should \e not copy data values, but must copy all
other fields in the object.
</pre> <dl class="section return"><dt>Returns</dt><dd>A newly allocated copy of <code>this</code>. </dd></dl>

<p>Implements <a class="el" href="classlibdap_1_1Vector.html#a08158ed75b297c395e2f665958be0ffe">libdap::Vector</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00175">175</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1da003c53f2e663223f603ab3fbd7c8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data into a local buffer. </p>
<p>This method should be implemented for each of the data type classes (<a class="el" href="classlibdap_1_1Byte.html" title="Holds a single byte. ">Byte</a>, ..., <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>) when using the DAP class library to build a server. This method is only for DAP servers. The library provides a default definition here which throws an <a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a> exception <em>unless</em> the read_p property has been set. In that case it returns false, indicating that all the data have been read. The latter case can happen when building a constant value that needs to be passed to a function. The variable/constant is loaded with a value when it is created.</p>
<p>When implementing a new DAP server, the <a class="el" href="classlibdap_1_1Byte.html" title="Holds a single byte. ">Byte</a>, ..., <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> data type classes are usually specialized. In each of those specializations <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> should be defined to read values from the data source and store them in the object's local buffer. The <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method is called by other methods in this library. When writing <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a>, follow these rules:</p>
<ul>
<li>
<a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> should throw <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a> if it encounters an error. The message should be verbose enough to be understood by someone running a client on a different machine. </li>
<li>
The value(s) should be read if and only if either <a class="el" href="classlibdap_1_1BaseType.html#a980c0013817836aa77ef74aeec7fb192" title="Should this variable be sent? ">send_p()</a> or <a class="el" href="classlibdap_1_1BaseType.html#ae302ab2ec26e9fc5b575bf5d3d09aa5c" title="Is this variable part of the current selection? ">is_in_selection()</a> return true. If neither of these return true, the value(s) should not be read. This is important when writing <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> for a <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a> type such as <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> where a client may ask for only the map vectors (and thus reading the much larger <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> part is not needed). </li>
<li>
For each specialization of <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a>, the method should first test the value of the <code>read_p</code> property (using the <a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a> method) and read values only if the value of <a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a> is false. Once the <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method reads data and stores it in the instance, it must set the value of the <code>read_p</code> property to true using <a class="el" href="classlibdap_1_1BaseType.html#a4533905a450d2a7af32e7d5acd557676" title="Sets the value of the read_p property. ">set_read_p()</a>. If your <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> methods fail to do this data may not serialize correctly. </li>
<li>
The <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">Array::read()</a> and <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Grid::read()</a> methods should take into account any restrictions on <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> sizes. </li>
<li>
If you are writing <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Sequence::read()</a>, be sure to check the documentation for <a class="el" href="classlibdap_1_1Sequence.html#a62d79555aa03b0a862314ccfdad090f8">Sequence::read_row()</a> and <a class="el" href="classlibdap_1_1Sequence.html#ad89a496720935e04e472a75ce7804065">Sequence::serialize()</a> so you understand how <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Sequence::read()</a> is being called. </li>
<li>
<p class="startli">For <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Sequence::read()</a>, your specialization must correctly manage the <code>unsent_data</code> property and row count in addition to the <code>read_p</code> property (handle the <code>read_p</code> property as describe above). For a <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> to serialize correctly, once all data from the <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> has been read, <code>unsent_data</code> property must be set to false (use <a class="el" href="classlibdap_1_1Sequence.html#ad7820138d2f1c9c8ff7dfa632dff60c2" title="Set the unsent data property. ">Sequence::set_unsent_data()</a>). Also, at that time the row number counter must be reset (use Sequence::reset_row_counter()). Typically the correct time to set <code>unsent_data</code> to false and reset the row counter is the time when <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Sequence::read()</a> return false indicating that all the data for the <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> have been read. Failure to handle these tasks will break serialization of nested Sequences. Note that when <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264" title="simple implementation of read that iterates through vars and calls read on them ">Sequence::read()</a> returns with a result of true (indicating there is more data to send, the value of the <code>unsent_data</code> property should be true.</p>
<p class="endli">Also, if you server must handle nested sequences, be sure to read about subclassing <a class="el" href="classlibdap_1_1BaseType.html#a4533905a450d2a7af32e7d5acd557676" title="Sets the value of the read_p property. ">set_read_p()</a>. </p>
</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Modify the D4 serialize code so that it supports the true/false behavior of <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> for arrays.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Modify all of the stock handlers so they conform to this!</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>False means more data remains to be read, True indicates that no more data need to be read. For <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> and <a class="el" href="classlibdap_1_1D4Sequence.html" title="Holds a sequence. ">D4Sequence</a>, this method will generally read one instance of the <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a>; for other types it will generally read the entire variable modulo any limitations due to a constraint. However, the library should be written so that read can return less than all of the data for a variable - <a class="el" href="classlibdap_1_1BaseType.html#adc24a735977e28acb0e6f78667c1dd21" title="Move data to the net, then remove them from the object. ">serialize()</a> would then call the function until it returns True.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1Constructor.html#ad0af40e2565972fa44985d173370c264">libdap::Constructor</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00890">890</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a38ff819a432217c55db2e9071928d20c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::read_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has this variable been read? </p>
<p>Returns true if the value(s) for this variable have been read from the data source, otherwise returns false. This method is used to determine when values need to be read using the <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">read()</a> method. When <a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a> returns true, this library assumes that <a class="el" href="classlibdap_1_1BaseType.html#accb15b7411e1988ef0a085ebdc88ce5d" title="Reads the class data. ">buf2val()</a> (and other methods such as get_vec()) can be used to access the value(s) of a variable.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the variable's value(s) have been read, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00471">471</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aaaa7c0f36266ef3df9f4fb90de220867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::reserve_value_capacity </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate enough memory for the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> to contain numElements data elements of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>'s type. Must be used before set_value_slice_from_row_major_vector to ensure memory exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numElements</td><td>the number of elements of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>'s type to preallocate storage for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>the memory cannot be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01435">1435</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adade15ffa55c59f6205e1c3c9ea78a35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::reserve_value_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure there's storage allocated for the current <a class="el" href="classlibdap_1_1Vector.html#a5990bd42b49e44c7b7da76e039896ba3">length()</a> of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>. Same as reserveValueCapacity(length()) </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01494">1494</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac375d728d50c8b27422c766c84e12300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::reset_constraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset constraint to select entire array. </p>
<p>Resets the dimension constraint information so that the entire array is selected. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00591">591</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a980c0013817836aa77ef74aeec7fb192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::send_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Should this variable be sent? </p>
<p>Returns the state of the <code>send_p</code> property. If true, this variable should be sent to the client, if false, it should not. If no constraint expression (CE) has been evaluated, this property is true for all variables in a data source (i.e., for all the variables listed in a <a class="el" href="classlibdap_1_1DDS.html">DDS</a>). If a CE has been evaluated, this property is true only for those variables listed in the <em>projection part</em> of the CE.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the variable should be sent to the client, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00545">545</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a993d46232faadb5914cc0519d013e9b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Vector::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1ConstraintEvaluator.html">ConstraintEvaluator</a> &amp;&#160;</td>
          <td class="paramname"><em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1DDS.html">DDS</a> &amp;&#160;</td>
          <td class="paramname"><em>dds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Marshaller.html">Marshaller</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ce_eval</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize a <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>. </p>
<p>This uses the Marshaler class to encode each element of a cardinal array. For Arrays of <a class="el" href="classlibdap_1_1Str.html" title="Holds character string data. ">Str</a> and <a class="el" href="classlibdap_1_1Url.html" title="Holds an Internet address (URL). ">Url</a> types, send the element count over as a prefix to the data so that deserialize will know how many elements to read.</p>
<p>NB: Arrays of cardinal types must already be in BUF (in the local machine's representation) <em>before</em> this call is made. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#adc24a735977e28acb0e6f78667c1dd21">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00670">670</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af478e3d5cbb3235081fe8daa6d6629a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1D4StreamMarshaller.html">D4StreamMarshaller</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1DMR.html">DMR</a> &amp;&#160;</td>
          <td class="paramname"><em>dmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The DAP4 serialization method. Serialize a variable's values for DAP4. This does not write the <a class="el" href="classlibdap_1_1DMR.html">DMR</a> persistent representation but does write that part of the binary data blob that holds a variable's data. Once a variable's data are serialized, that memory is reclaimed (by calling <a class="el" href="classlibdap_1_1BaseType.html#aaddb97a4efbe035f41deaf03c6e8683f">BaseType::clear_local_data()</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">dmr</td><td></td></tr>
    <tr><td class="paramname">eval</td><td></td></tr>
    <tr><td class="paramname">filter</td><td>True if there is one variable that should be 'filtered' </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>or <a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a30331db8b6a7cdc843652376fa683b71">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00967">967</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a572a1d76a75981abac83a4241e90c0fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::set_attr_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> &amp;&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set this variable's attribute table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at</td><td>Source of the attributes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00581">581</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2bc036248cdaf1affac464170f32ad30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::set_in_selection </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <em>in_selection</em> property to <em>state</em>. This property indicates that the variable is used as a parameter to a constraint expression function or that it appears as an argument in a selection sub-expression. If set (true), implementations of the <a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">BaseType::read()</a> method should read this variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Set the <em>in_selection</em> property to this state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#a1da003c53f2e663223f603ab3fbd7c8e" title="Read data into a local buffer. ">BaseType::read()</a> </dd>
<dd>
<a class="el" href="classlibdap_1_1BaseType.html#ae302ab2ec26e9fc5b575bf5d3d09aa5c" title="Is this variable part of the current selection? ">BaseType::is_in_selection()</a> for more information. </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1Constructor.html#ac30becb1ffe7d2cd4cbcd24fc216c9a3">libdap::Constructor</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00709">709</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a05a61e24fd295934dfc3c37c9f55ca57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_length </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the length of the vector. This function does not allocate any new space. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a4fe343c1eeb6fb1d61ab030433651d90">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00562">562</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aacfca48c7db65e3a2c3c94734dee8c36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the class instance. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a86504564f45a3e6748c6f1cc0ff4e9fa">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00324">324</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5b6a39f6ce6594fa74f3fc899ac9a966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::set_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the <code>parent</code> property for this variable.</p>
<dl class="section note"><dt>Note</dt><dd>Added ability to set parent to null. 10/19/12 jhrg</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Pointer to the <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a> of <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> parent variable or null if the variable has no parent (if it is at the top-level of a DAP2/3 <a class="el" href="classlibdap_1_1DDS.html">DDS</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>thrown if called with anything other than a <a class="el" href="classlibdap_1_1Constructor.html">Constructor</a>, <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> or Null. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00724">724</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a58712de8871e28a48fdc95e72a09df71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_read_p </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the data is ready to send. </p>
<p>This function sets the <code>read_p</code> flag for both the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> itself and its element template. This does not matter much when the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains simple data types, but does become significant when the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains compound types. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a4533905a450d2a7af32e7d5acd557676">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00392">392</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a64815467570490a4a6cddc89f09a2413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_send_p </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates that the data is ready to send. </p>
<p>This function sets the <code>send_p</code> flag for both the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> itself and its element template. This does not matter much when the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains simple data types, but does become significant when the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains compound types. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#aba7b27635c95b74536de18393133628e">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00355">355</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a595cb4059cff24f801a1b6da79bd2f9e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::set_synthesized_p </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the synthesized flag. Before setting this flag be sure to set the <code><a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a></code> state. Once this flag is set you cannot alter the state of the <code>read_p</code> flag!</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#ae64e677da27249473cdba0b60cdbb90a">synthesized_p()</a> </dd></dl>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00454">454</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af74f8d1ef57c9fcca46f620f75d175a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::set_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibdap.html#a05ca706d4539ae7b750c3bc7066ab6e6">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the type of the class instance. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00363">363</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abd6e429e907214c593b6fb37f97511ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Vector::set_value </td>
          <td>(</td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the value of a string or url array </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01735">1735</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a068afd2353ad32f904361253e1b6e807"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::Vector::set_value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the value of a string or url array </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01801">1801</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a559d8ca948ca40f179e4e3da0bfdfdc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::set_value_slice_from_row_major_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rowMajorDataC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>startElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy rowMajorData.length() elements currently in a rowMajorData buffer into this value buffer starting at element index startElement and continuing up to startElement+rowMajorData.<a class="el" href="classlibdap_1_1Vector.html#a5990bd42b49e44c7b7da76e039896ba3">length()</a>-1</p>
<p>This is used for aggregating together smaller rowMajor vectors into a larger one.</p>
<p>Note: unlike the other set_value calls, this does NOT set <a class="el" href="classlibdap_1_1BaseType.html#a38ff819a432217c55db2e9071928d20c" title="Has this variable been read? ">read_p()</a> since it is assumed to be used as a partial read and the caller is expected to <a class="el" href="classlibdap_1_1Vector.html#a58712de8871e28a48fdc95e72a09df71" title="Indicates that the data is ready to send. ">set_read_p()</a> when the data is complete.</p>
<p>ASSUMES: rowMajorData.read_p() so that the data is valid! ASSUMES: this <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> has enough value_capacity() to contain all the elements such that: startElement + rowMajorData.length() &lt;= this-&gt;value_capacity(). ASSUMES: the data type of this-&gt;<a class="el" href="classlibdap_1_1Vector.html#aa5ccb30d1f27ae587f35216b859feec7">var()</a> and rowMajorData.var() MUST be non-NULL and be the same!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowMajorDataC</td><td>the vector from which to copy data, assumed already read in or set. </td></tr>
    <tr><td class="paramname">startElement</td><td>the element index (NOT byte, but rather data type element) to place the first data value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added, such that: startElement + the return value is the next "free" element. </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01529">1529</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8bf6e565dcb2eab1f3f7037518a9acb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_vec </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element <em>i</em> to value <em>val</em>. </p>
<p>Sets an element of the vector to a given value. If the type of the input and the type of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> do not match, an error condition is returned.</p>
<p>Use this function only with Vectors containing compound types. See <code><a class="el" href="classlibdap_1_1Vector.html#af20a56a72c3108b31418ebf01f779253">buf2val()</a></code> or the <code>set_value()</code> methods to access members of <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> containing simple types.</p>
<dl class="section note"><dt>Note</dt><dd>This method copies <em>val</em>; the caller is responsible for deleting instance passed as the actual parameter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if <em>i</em> is out of range, <em>val</em> is null or there was a type mismatch between the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> referenced by <em>val</em> and the <em>ith</em> element of this <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element to be changed. </td></tr>
    <tr><td class="paramname">val</td><td>A pointer to the value to be inserted into the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Vector.html#af20a56a72c3108b31418ebf01f779253">Vector::buf2val</a> </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01341">1341</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a175f1a51686798061c2147f2eccde33a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::set_vec_nocopy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element <em>i</em> to value <em>val</em>. Set the ith element to val. Extend the vector if needed. </p>
<dl class="section note"><dt>Note</dt><dd>It is best to call <a class="el" href="classlibdap_1_1Vector.html#ad180a87244b0b6f32b47711a4ae0330e">vec_resize()</a> first and allocate enough elements before calling this method.</dd>
<dd>
This method does not copy <em>val</em>; this class will free the instance when the variable is deleted or when <a class="el" href="classlibdap_1_1Vector.html#ac12023f8bf9ecc97998c3bb021ba2772">clear_local_data()</a> is called. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Vector.html#a8bf6e565dcb2eab1f3f7037518a9acb3" title="Sets element i to value val. ">Vector::set_vec()</a> </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01357">1357</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae64e677da27249473cdba0b60cdbb90a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::BaseType::synthesized_p </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the variable is a synthesized variable. A synthesized variable is one that is added to the dataset by the server (usually with a `projection function'. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00443">443</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a701eb3361f5b5628329ece019cd34519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::BaseType::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write out the object's internal fields in a string. To be used for debugging when regular inspection w/ddd or gdb isn't enough.</p>
<dl class="section return"><dt>Returns</dt><dd>A string which shows the object's internal stuff. </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1Sequence.html#a24016ba1d3b9b755699959abf0219ff1">libdap::Sequence</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00183">183</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="add8e836c622042a339152a6c31e5bdfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::BaseType::transfer_attributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> *&#160;</td>
          <td class="paramname"><em>at_container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfer attributes from a <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a> object into this variable. Because of the rough history of the <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a> object and the way that various server code built the <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a>, this is necessarily a heuristic process. The intent is that this method will be overridden by handlers that need to look for certain patterns in the <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a> (e.g., hdf4's odd variable_dim_n; where n = 0, 1, 2, ...) attribute containers.</p>
<p>There should be a one-to-one mapping between variables and attribute containers. However, in some cases one variable has attributes spread across several top level containers and in some cases one container is used by several variables</p>
<dl class="section note"><dt>Note</dt><dd>This method is technically <em>unnecessary</em> because a server (or client) can easily add attributes directly using the <a class="el" href="classlibdap_1_1DDS.html#a177e3df069cb0dcb3b30c0dcd236f8b3">DDS::get_attr_table</a> or <a class="el" href="classlibdap_1_1BaseType.html#a1fcd9537c67e3bf88964b2656ff5bac1">BaseType::get_attr_table</a> methods and then poke values in using any of the methods <a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> provides. This method exists to ease the transition to <a class="el" href="classlibdap_1_1DDS.html">DDS</a> objects which contain attribute information for the existing servers (Since they all make <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a> objects separately from the <a class="el" href="classlibdap_1_1DDS.html">DDS</a>). They could be modified to use the same <a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> methods but operate on the <a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> instances in a DDS/BaseType instead of those in a <a class="el" href="classlibdap_1_1DAS.html" title="Hold attribute data for a DAP2 dataset. ">DAS</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at_container</td><td>Transfer attributes from this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

<p>Reimplemented in <a class="el" href="classlibdap_1_1Grid.html#a9483bb65505c86e3fc44a9b856a55323">libdap::Grid</a>, and <a class="el" href="classlibdap_1_1Constructor.html#a799d2bd8ef9505b1d493d8cd73b72746">libdap::Constructor</a>.</p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00635">635</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1cc230189460ef65076e8091cf3b6e36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * &gt; * libdap::Array::transform_to_dap2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1AttrTable.html">AttrTable</a> *&#160;</td>
          <td class="paramname"><em>parent_attr_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms this instance of a D4Array into the corresponding DAP2 object. </p>
<p>This transformation may return an <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> or a <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> object. The DAP2 <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> construct is semantically contained in the DAP4 concept of arrays with Map arrays. If all of the Maps are one dimensional then the D4Array can be represented as a <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td><a class="el" href="classlibdap_1_1AttrTable.html" title="Contains the attributes for a dataset. ">AttrTable</a> pointer parent_attr_table is used by Groups, which disappear from the DAP2 representation. Their children are returned in the the BAseType vector their attributes are added to parent_attr_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a vector of <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointers (right?). In this D4Array case returned vector may contain a DAP2 <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> or a <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>. Or, if the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a>' prototype is a type that cannot be represented in DAP2 the return will be NULL. </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#affec8a11e9cc035d4b1e8fb9a87b2072">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00308">308</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2dea8a711559cb0e0b9c36bf41df6473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::transform_to_dap4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1D4Group.html">D4Group</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibdap_1_1Constructor.html">Constructor</a> *&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DAP2 to DAP4 transform. </p>
<p>For the current <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a>, return a DAP4 'copy' of the variable.</p>
<dl class="section note"><dt>Note</dt><dd>For most DAP2 types, in this implementation of DAP4 the corresponding DAP4 type is the same. The different types are Sequences (which are D4Sequences in the DAP4 implementation), Grids (which are coverages) and Arrays (which use shared dimensions).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root group that should hold this new variable. Add Group-level stuff here (e.g., <a class="el" href="classlibdap_1_1D4Dimensions.html">D4Dimensions</a>). </td></tr>
    <tr><td class="paramname">container</td><td>Add the new variable to this container.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the transformed variable </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#adb03e2e1e40c3c888577c4666831a949">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00194">194</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abc6b2d7099f00bb5f324ec129bff2a17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibdap.html#a05ca706d4539ae7b750c3bc7066ab6e6">Type</a> libdap::BaseType::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the class instance. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00356">356</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac4461c9e287b167871acade5e5472116"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::BaseType::type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the class instance as a string. </p>

<p>Definition at line <a class="el" href="BaseType_8cc_source.html#l00370">370</a> of file <a class="el" href="BaseType_8cc_source.html">BaseType.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4fe08ce144a3fa2d6b15b7ae15ccc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Array::update_length </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Calling this method should never be necessary. It is used internally called whenever the size of the <a class="el" href="classlibdap_1_1Array.html" title="A multidimensional array of identical data types. ">Array</a> is changed, e.g., by a constraint.</dd></dl>
<p>Changes the length property of the array. </p>

<p>Definition at line <a class="el" href="Array_8cc_source.html#l00104">104</a> of file <a class="el" href="Array_8cc_source.html">Array.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a96ecf84f2798065878755d9a9014ee69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::val2buf </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data into the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> buffer. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if called for <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>. </td></tr>
  </table>
  </dd>
</dl>
</p>
<p>Copies data into the class instance buffer. This function assumes that the input <em>val</em> points to memory which contains, in row major order, enough elements of the correct type to fill the array. For an array of a cardinal type the memory is simply copied in whole into the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> buffer.</p>
<p>If the variable has already been constrained, this method will load only number of values/bytes specified by that constraint and will load them into the 'front' of the object's internal buffer. This is where <a class="el" href="classlibdap_1_1Vector.html#a993d46232faadb5914cc0519d013e9b2" title="Serialize a Vector. ">serialize()</a> expects to find the data.</p>
<p>For a <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> of <a class="el" href="classlibdap_1_1Str.html" title="Holds character string data. ">Str</a> (OPeNDAP Strings), this assumes <em>val</em> points to an array of C++ strings.</p>
<p>This method should not be used for <a class="el" href="classlibdap_1_1Structure.html" title="Holds a structure (aggregate) type. ">Structure</a>, <a class="el" href="classlibdap_1_1Sequence.html" title="Holds a sequence. ">Sequence</a> or <a class="el" href="classlibdap_1_1Grid.html" title="Holds the Grid data type. ">Grid</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes used by the array. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>A pointer to the input data. </td></tr>
    <tr><td class="paramname">reuse</td><td>A boolean value, indicating whether the class internal data storage can be reused or not. If this argument is TRUE, the class buffer is assumed to be large enough to hold the incoming data, and it is <em>not</em> reallocated. If FALSE, new storage is allocated. If the internal buffer has not been allocated at all, this argument has no effect. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlibdap_1_1BaseType.html#ac360679317a411d7812ca235a1528281">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01165">1165</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a65aa003dc71e226e137b188213e78eb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the data held by this variable. </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01942">1942</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a00c287b51ec6d033e57c93f4a85f2ae5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::value </td>
          <td>(</td>
          <td class="paramtype">vector&lt; unsigned int &gt; *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the data held by this variable using the passed subsetIndex vector to identify which values to return. </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01890">1890</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aca5000630369cb4217827c2f136afec0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * libdap::Vector::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate memory and copy data into the new buffer. Return the new buffer's pointer. The caller must delete the storage. </p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l01950">1950</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa5ccb30d1f27ae587f35216b859feec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * libdap::Vector::var </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btp_stack *&#160;</td>
          <td class="paramname"><em>s</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the template array element. If the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains simple data types, the template will contain the value of the last vector element accessed with the <code>Vector::var(int i)</code> function, if any. If no such access has been made, or if the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> contains compound data types, the value held by the template instance is undefined.</p>
<p>Note that the parameter <em>exact_match</em> is not used by this mfunc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The name of the variable to find. </td></tr>
    <tr><td class="paramname">exact</td><td>Unused. </td></tr>
    <tr><td class="paramname">s</td><td>Pointer to a <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> Pointer Stack. Use this stack to record the path to the variable. By default this pointer is null, in which case it is not used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> if found, otherwise null. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1Vector.html#aa5ccb30d1f27ae587f35216b859feec7">Vector::var</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a4dc4fac1bb6083f6db645f37bfd59b85">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00434">434</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac07a950727d2ac58934ba4cc03206c8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * libdap::Vector::var </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">btp_stack &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This version of var(...) searches for <em>name</em> and returns a pointer to the <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> object if found. It uses the same search algorithm as above when <em>exact_match</em> is false. In addition to returning a pointer to the variable, it pushes onto <em>s</em> a <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer to each constructor type that ultimately contains <em>name</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Find the variable whose name is <em>name</em>. </td></tr>
    <tr><td class="paramname">s</td><td>Record the path to <em>name</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the named variable. </dd></dl>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#adecfc442b5927c79933c7f71cfe03fd2">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00468">468</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="adf286762e63295675850c41cedf33370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1BaseType.html">BaseType</a> * libdap::Vector::var </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the specified <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> element. The return pointer will reference the element itself, so multiple calls to this method should save each value before making the next call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the desired <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> element. Zero indicates the first element of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> class instance containing the value of the indicated element. The <a class="el" href="classlibdap_1_1BaseType.html" title="The basic data type for the DODS DAP types. ">BaseType</a> pointer is locally maintained and should not be deleted or referenced. Extract the value right after the method returns. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibdap_1_1BaseType.html#a4dc4fac1bb6083f6db645f37bfd59b85" title="Returns a pointer to a member of a constructor class. ">BaseType::var</a> </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00491">491</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad180a87244b0b6f32b47711a4ae0330e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::Vector::vec_resize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes a <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>. If the input length is greater than the current length of the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a>, new memory is allocated (the <a class="el" href="classlibdap_1_1Vector.html" title="Holds a one-dimensional collection of DAP2 data types. ">Vector</a> moved if necessary), and the new entries are appended to the end of the array and padded with Null values. If the input length is shorter, the tail values are discarded.</p>
<dl class="section note"><dt>Note</dt><dd>This method is applicable to the compound types only. </dd></dl>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00575">575</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8e2f0c4e4901b7b98c3178e551edc95e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int libdap::Vector::width </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>constrained</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width of the data, in bytes. </p>
<p>Returns the number of bytes needed to hold the entire array. This is equal to <code><a class="el" href="classlibdap_1_1Vector.html#a5990bd42b49e44c7b7da76e039896ba3">length()</a></code> (the number of elements in in the array) times the width of each element. </p>

<p>Reimplemented from <a class="el" href="classlibdap_1_1BaseType.html#a27045bdf043418ef2ddfaad597a3cff9">libdap::BaseType</a>.</p>

<p>Definition at line <a class="el" href="Vector_8cc_source.html#l00543">543</a> of file <a class="el" href="Vector_8cc_source.html">Vector.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Array_8h_source.html">Array.h</a></li>
<li><a class="el" href="Array_8cc_source.html">Array.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1Array.html">Array</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
