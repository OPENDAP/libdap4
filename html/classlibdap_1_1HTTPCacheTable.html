<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdap: libdap::HTTPCacheTable Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.20.6</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibdap_1_1HTTPCacheTable.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibdap_1_1HTTPCacheTable-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libdap::HTTPCacheTable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="HTTPCacheTable_8h_source.html">HTTPCacheTable.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36425575bbfac384964ce2f364f15679"><td class="memItemLeft" align="right" valign="top"><a id="a36425575bbfac384964ce2f364f15679"></a>
typedef vector&lt; <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CacheEntries</b></td></tr>
<tr class="separator:a36425575bbfac384964ce2f364f15679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8527d6a5b1e720e2d500e1ec1eeecf9f"><td class="memItemLeft" align="right" valign="top"><a id="a8527d6a5b1e720e2d500e1ec1eeecf9f"></a>
typedef CacheEntries::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>CacheEntriesIter</b></td></tr>
<tr class="separator:a8527d6a5b1e720e2d500e1ec1eeecf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e43995c010ac4fae6ca8cc13395930"><td class="memItemLeft" align="right" valign="top"><a id="aa8e43995c010ac4fae6ca8cc13395930"></a>
typedef CacheEntries **&#160;</td><td class="memItemRight" valign="bottom"><b>CacheTable</b></td></tr>
<tr class="separator:aa8e43995c010ac4fae6ca8cc13395930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24b2c86910ba623a59184ab42410b4cb"><td class="memItemLeft" align="right" valign="top"><a id="a24b2c86910ba623a59184ab42410b4cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bind_entry_to_data</b> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *entry, FILE *body)</td></tr>
<tr class="separator:a24b2c86910ba623a59184ab42410b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7f6193848fb3ba8ad17082fd95b6c6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a0f7f6193848fb3ba8ad17082fd95b6c6">create_hash_directory</a> (int hash)</td></tr>
<tr class="separator:a0f7f6193848fb3ba8ad17082fd95b6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab52cb3d5d01575977adb33a21b31d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a0ab52cb3d5d01575977adb33a21b31d2">create_location</a> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *entry)</td></tr>
<tr class="separator:a0ab52cb3d5d01575977adb33a21b31d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51707b1b5533c2d06e57dc52a0ea90b2"><td class="memItemLeft" align="right" valign="top"><a id="a51707b1b5533c2d06e57dc52a0ea90b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_by_hits</b> (int hits)</td></tr>
<tr class="separator:a51707b1b5533c2d06e57dc52a0ea90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04655ab9af621a261420ed8af681cf80"><td class="memItemLeft" align="right" valign="top"><a id="a04655ab9af621a261420ed8af681cf80"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_by_size</b> (unsigned int size)</td></tr>
<tr class="separator:a04655ab9af621a261420ed8af681cf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107d8cc87728a855eaa18210b90c09d5"><td class="memItemLeft" align="right" valign="top"><a id="a107d8cc87728a855eaa18210b90c09d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_expired_entries</b> (time_t time=0)</td></tr>
<tr class="separator:a107d8cc87728a855eaa18210b90c09d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e241526025dfaeb2662f7c15ce1d17"><td class="memItemLeft" align="right" valign="top"><a id="a03e241526025dfaeb2662f7c15ce1d17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HTTPCacheTable</b> (const string &amp;cache_root, int block_size)</td></tr>
<tr class="separator:a03e241526025dfaeb2662f7c15ce1d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ef03d687c3db809e2bfbc3bca3bd3"><td class="memItemLeft" align="right" valign="top"><a id="afc2ef03d687c3db809e2bfbc3bca3bd3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_locked_read_responses</b> ()</td></tr>
<tr class="separator:afc2ef03d687c3db809e2bfbc3bca3bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ac242f618a804562e18546738904df"><td class="memItemLeft" align="right" valign="top"><a id="ad0ac242f618a804562e18546738904df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uncouple_entry_from_data</b> (FILE *body)</td></tr>
<tr class="separator:ad0ac242f618a804562e18546738904df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acafa29f363fd70558e3719b34178fe2d"><td class="memItemLeft" align="right" valign="top"><a id="acafa29f363fd70558e3719b34178fe2d"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_size</b> () const</td></tr>
<tr class="separator:acafa29f363fd70558e3719b34178fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4e75cf192355d7c7bfcf9f0e736168"><td class="memItemLeft" align="right" valign="top"><a id="abf4e75cf192355d7c7bfcf9f0e736168"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_current_size</b> (unsigned long sz)</td></tr>
<tr class="separator:abf4e75cf192355d7c7bfcf9f0e736168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7c90f1c20eb4b8bc2e8f056be5ad50"><td class="memItemLeft" align="right" valign="top"><a id="a3c7c90f1c20eb4b8bc2e8f056be5ad50"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>get_block_size</b> () const</td></tr>
<tr class="separator:a3c7c90f1c20eb4b8bc2e8f056be5ad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe278c93c2d3a0dc2f180fefc6ae3c"><td class="memItemLeft" align="right" valign="top"><a id="a3ffe278c93c2d3a0dc2f180fefc6ae3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_block_size</b> (unsigned int sz)</td></tr>
<tr class="separator:a3ffe278c93c2d3a0dc2f180fefc6ae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade9a27801741f7c01d62b9ae22f25ae"><td class="memItemLeft" align="right" valign="top"><a id="aade9a27801741f7c01d62b9ae22f25ae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_new_entries</b> () const</td></tr>
<tr class="separator:aade9a27801741f7c01d62b9ae22f25ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17bd7a96186412f3ef53caed42db767"><td class="memItemLeft" align="right" valign="top"><a id="af17bd7a96186412f3ef53caed42db767"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>increment_new_entries</b> ()</td></tr>
<tr class="separator:af17bd7a96186412f3ef53caed42db767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f13e699f533ebdfd4e7ca3ef83401d"><td class="memItemLeft" align="right" valign="top"><a id="a86f13e699f533ebdfd4e7ca3ef83401d"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>get_cache_root</b> ()</td></tr>
<tr class="separator:a86f13e699f533ebdfd4e7ca3ef83401d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6fada9e04ddcf835160780222e9a43"><td class="memItemLeft" align="right" valign="top"><a id="a9e6fada9e04ddcf835160780222e9a43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_cache_root</b> (const string &amp;cr)</td></tr>
<tr class="separator:a9e6fada9e04ddcf835160780222e9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cache Index</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods manage the cache's index file. Each cache holds an index file named <code></code>.index which stores the cache's state information. </p>
</div></td></tr>
<tr class="memitem:a3e636690b069b3384e908135fcaebd51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a3e636690b069b3384e908135fcaebd51">cache_index_delete</a> ()</td></tr>
<tr class="separator:a3e636690b069b3384e908135fcaebd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e70dae002ffeef9641bb6493109513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a24e70dae002ffeef9641bb6493109513">cache_index_read</a> ()</td></tr>
<tr class="separator:a24e70dae002ffeef9641bb6493109513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48569affedb01e6e0e87343bcc621c0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a48569affedb01e6e0e87343bcc621c0a">cache_index_parse_line</a> (const char *line)</td></tr>
<tr class="separator:a48569affedb01e6e0e87343bcc621c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5a3a24fd0cd41ac0d9a3192075e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a7cd5a3a24fd0cd41ac0d9a3192075e9c">cache_index_write</a> ()</td></tr>
<tr class="separator:a7cd5a3a24fd0cd41ac0d9a3192075e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a76bd6ce419aad54c8c87e993f5bd11c9"><td class="memItemLeft" align="right" valign="top"><a id="a76bd6ce419aad54c8c87e993f5bd11c9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HTTPCacheTest</b></td></tr>
<tr class="separator:a76bd6ce419aad54c8c87e993f5bd11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Methods to manipulate instances of CacheEntry.</h2></td></tr>
<tr class="memitem:ad02f9346125f4c311d6e74b6a8354f9e"><td class="memItemLeft" align="right" valign="top"><a id="ad02f9346125f4c311d6e74b6a8354f9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_all_entries</b> ()</td></tr>
<tr class="separator:ad02f9346125f4c311d6e74b6a8354f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5660848048a98454fce23c28de573c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a8f5660848048a98454fce23c28de573c">add_entry_to_cache_table</a> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *entry)</td></tr>
<tr class="separator:a8f5660848048a98454fce23c28de573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4438820f0920002f5e77b51900ea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a85d4438820f0920002f5e77b51900ea9">remove_cache_entry</a> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *entry)</td></tr>
<tr class="separator:a85d4438820f0920002f5e77b51900ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b8ffd257ff335b3d87b90600f5bffd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#ad1b8ffd257ff335b3d87b90600f5bffd">remove_entry_from_cache_table</a> (const string &amp;url)</td></tr>
<tr class="separator:ad1b8ffd257ff335b3d87b90600f5bffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c8e58c208b8c542b89f500829032a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#ac8c8e58c208b8c542b89f500829032a0">get_locked_entry_from_cache_table</a> (const string &amp;url)</td></tr>
<tr class="separator:ac8c8e58c208b8c542b89f500829032a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c01c8b9462f0e0ea6541b7d9fcf2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a57c01c8b9462f0e0ea6541b7d9fcf2f5">get_write_locked_entry_from_cache_table</a> (const string &amp;url)</td></tr>
<tr class="separator:a57c01c8b9462f0e0ea6541b7d9fcf2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca63c76e70064549d128ff8f5951534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a0ca63c76e70064549d128ff8f5951534">calculate_time</a> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *entry, int default_expiration, time_t request_time)</td></tr>
<tr class="separator:a0ca63c76e70064549d128ff8f5951534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53379f3151fe6b85e85c75c401a14963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1HTTPCacheTable.html#a53379f3151fe6b85e85c75c401a14963">parse_headers</a> (<a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *entry, unsigned long max_entry_size, const vector&lt; string &gt; &amp;headers)</td></tr>
<tr class="separator:a53379f3151fe6b85e85c75c401a14963"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The table of entries in the client-side cache. This class maintains a table of CacheEntries, where one instance of <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> is made for each item in the cache. When an item is accessed it is either locked for reading or writing. When locked for reading the entry is recorded on a list of read-locked entries. The caller must explicitly free the entry for it to be removed from this list (which is the only way it can be opened for writing). An entry can be accessed by multiple readers but only one writer.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> class used to contain a lock that was used to ensure that the entry was locked during any changes to any of its fields. That has been removed - its now the responsibility of the caller. This change was made because it's likely the caller will need to lock all of the methods that operate on a <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> anyway, so the CacheEntry-specific lock was redundant. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8h_source.html#l00101">101</a> of file <a class="el" href="HTTPCacheTable_8h_source.html">HTTPCacheTable.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f5660848048a98454fce23c28de573c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5660848048a98454fce23c28de573c">&#9670;&nbsp;</a></span>add_entry_to_cache_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::add_entry_to_cache_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> to the cache table. As each entry is read, load it into the in-memory cache table and update the <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a>'s current_size. The later is used by the garbage collection method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> instance to add. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00562">562</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a3e636690b069b3384e908135fcaebd51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e636690b069b3384e908135fcaebd51">&#9670;&nbsp;</a></span>cache_index_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCacheTable::cache_index_delete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the cache index file.</p>
<p>A private method.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the file was deleted, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00282">282</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a48569affedb01e6e0e87343bcc621c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48569affedb01e6e0e87343bcc621c0a">&#9670;&nbsp;</a></span>cache_index_parse_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> * libdap::HTTPCacheTable::cache_index_parse_line </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse one line of the index file.</p>
<p>A private method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>A single line from the <code></code>.index file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> initialized with the information from <code>line</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00331">331</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a24e70dae002ffeef9641bb6493109513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e70dae002ffeef9641bb6493109513">&#9670;&nbsp;</a></span>cache_index_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCacheTable::cache_index_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the saved set of cached entries from disk. Consistency between the in-memory cache and the index is maintained by only reading the index file when the <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> object is created!</p>
<p>A private method.</p>
<dl class="section return"><dt>Returns</dt><dd>True when a cache index was found and read, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00298">298</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a7cd5a3a24fd0cd41ac0d9a3192075e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd5a3a24fd0cd41ac0d9a3192075e9c">&#9670;&nbsp;</a></span>cache_index_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::cache_index_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk through the list of cached objects and write the cache index file to disk. If the file does not exist, it is created. If the file does exist, it is overwritten. As a side effect, zero the new_entries counter.</p>
<p>A private method.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>Thrown if the index file cannot be opened for writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> destructor calls this method and silently ignores this exception. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00402">402</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a0ca63c76e70064549d128ff8f5951534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca63c76e70064549d128ff8f5951534">&#9670;&nbsp;</a></span>calculate_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::calculate_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>default_expiration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>request_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the corrected_initial_age of the object. We use the time when this function is called as the response_time as this is when we have received the complete response. This may cause a delay if the response header is very big but should not cause any incorrect behavior.</p>
<p>A private method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> object. </td></tr>
    <tr><td class="paramname">default_expiration</td><td>The default value of the cached object's expiration time. </td></tr>
    <tr><td class="paramname">request_time</td><td>When was the request made? I think this value must be passed into the method that calls this method... </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00761">761</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a0f7f6193848fb3ba8ad17082fd95b6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7f6193848fb3ba8ad17082fd95b6c6">&#9670;&nbsp;</a></span>create_hash_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string libdap::HTTPCacheTable::create_hash_directory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the directory path for cache file. The cache uses a set of directories within d_cache_root to store individual responses. The name of the directory that holds a given response is the value returned by the <a class="el" href="namespacelibdap.html#a68a16ef70e29c367dabd3cb5165c386a">get_hash()</a> function (i.e., it's a number). If the directory exists, this method does nothing.</p>
<p>A private method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash value (i.e., directory name). An integer between 0 and CACHE_TABLE_SIZE (See <a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pathname to the directory (even if it already existed). </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>Thrown if the directory cannot be created. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00447">447</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a0ab52cb3d5d01575977adb33a21b31d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab52cb3d5d01575977adb33a21b31d2">&#9670;&nbsp;</a></span>create_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::create_location </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the directory for this url (using the hash value from <a class="el" href="namespacelibdap.html#a68a16ef70e29c367dabd3cb5165c386a">get_hash()</a>) and a file within that directory to hold the response's information. The cache name and cache_body_fd fields of <code>entry</code> are updated.</p>
<p>mkstemp opens the file it creates, which is a good thing but it makes tracking resources hard for the <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> object (because an exception might cause a file descriptor resource leak). So I close that file descriptor here.</p>
<p>A private method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The cache entry object to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing. ">Error</a></td><td>If the file for the response's body cannot be created. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00505">505</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="ac8c8e58c208b8c542b89f500829032a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c8e58c208b8c542b89f500829032a0">&#9670;&nbsp;</a></span>get_locked_entry_from_cache_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> * libdap::HTTPCacheTable::get_locked_entry_from_cache_table </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to a <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> from the cache table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Look for this URL. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00588">588</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a57c01c8b9462f0e0ea6541b7d9fcf2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c01c8b9462f0e0ea6541b7d9fcf2f5">&#9670;&nbsp;</a></span>get_write_locked_entry_from_cache_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> * libdap::HTTPCacheTable::get_write_locked_entry_from_cache_table </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to a <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> from the cache table. Providing a way to pass the hash code into this method makes it easier to test for correct behavior when two entries collide. 10/07/02 jhrg</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Look for this URL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matching <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> instance or NULL if none was found. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00627">627</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a53379f3151fe6b85e85c75c401a14963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53379f3151fe6b85e85c75c401a14963">&#9670;&nbsp;</a></span>parse_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::parse_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>max_entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>headers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse various headers from the vector (which can be retrieved from libcurl once a response is received) and load the <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> object with values. This method should only be called with headers from a response (it should not be used to parse request headers).</p>
<p>A private method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Store values from the headers here. </td></tr>
    <tr><td class="paramname">max_entry_size</td><td>DO not cache entries larger than this. </td></tr>
    <tr><td class="paramname">headers</td><td>A vector of header lines. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00804">804</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="a85d4438820f0920002f5e77b51900ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d4438820f0920002f5e77b51900ea9">&#9670;&nbsp;</a></span>remove_cache_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::remove_cache_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a>. This means delete the entry's files on disk and free the <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> object. The caller should null the entry's pointer in the cache_table. The total size of the cache is decremented once the entry is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>The <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if <code>entry</code> is in use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00653">653</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<a id="ad1b8ffd257ff335b3d87b90600f5bffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b8ffd257ff335b3d87b90600f5bffd">&#9670;&nbsp;</a></span>remove_entry_from_cache_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCacheTable::remove_entry_from_cache_table </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> for the given url and remove both its information in the persistent store and the entry in d_cache_table. If <code>url</code> is not in the cache, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Remove this URL's entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting. ">InternalErr</a></td><td>Thrown if the <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">CacheEntry</a> for <code>url</code> is locked. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCacheTable_8cc_source.html#l00701">701</a> of file <a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="HTTPCacheTable_8h_source.html">HTTPCacheTable.h</a></li>
<li><a class="el" href="HTTPCacheTable_8cc_source.html">HTTPCacheTable.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1HTTPCacheTable.html">HTTPCacheTable</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
