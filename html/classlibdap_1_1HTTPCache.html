<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libdap: libdap::HTTPCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libdap<span id="projectnumber">&#160;Updated for version 3.21.1</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classlibdap_1_1HTTPCache.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classlibdap_1_1HTTPCache-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">libdap::HTTPCache Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for libdap::HTTPCache:</div>
<div class="dyncontent">
<div class="center"><img src="classlibdap_1_1HTTPCache__coll__graph.png" border="0" usemap="#alibdap_1_1HTTPCache_coll__map" alt="Collaboration graph"/></div>
<map name="alibdap_1_1HTTPCache_coll__map" id="alibdap_1_1HTTPCache_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,204,815"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8d79d640be07aa8ea145247fccb775bf" id="r_a8d79d640be07aa8ea145247fccb775bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d79d640be07aa8ea145247fccb775bf">cache_response</a> (const std::string &amp;url, time_t request_time, const std::vector&lt; std::string &gt; &amp;headers, const FILE *body)</td></tr>
<tr class="separator:a8d79d640be07aa8ea145247fccb775bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5138cebe8a7fa99c25bdedad967c95" id="r_a1b5138cebe8a7fa99c25bdedad967c95"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b5138cebe8a7fa99c25bdedad967c95">get_cached_response</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a1b5138cebe8a7fa99c25bdedad967c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a4b33674f9fd51d0dde6afabb50bc" id="r_a562a4b33674f9fd51d0dde6afabb50bc"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a562a4b33674f9fd51d0dde6afabb50bc">get_cached_response</a> (const std::string &amp;url, std::vector&lt; std::string &gt; &amp;headers)</td></tr>
<tr class="separator:a562a4b33674f9fd51d0dde6afabb50bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b56b7bf4e26dc9dcdb8e9446c514f9" id="r_a71b56b7bf4e26dc9dcdb8e9446c514f9"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b56b7bf4e26dc9dcdb8e9446c514f9">get_cached_response</a> (const std::string &amp;url, std::vector&lt; std::string &gt; &amp;headers, std::string &amp;cacheName)</td></tr>
<tr class="separator:a71b56b7bf4e26dc9dcdb8e9446c514f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb7b70431ed7cf389485b2f5514699a" id="r_a2bb7b70431ed7cf389485b2f5514699a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bb7b70431ed7cf389485b2f5514699a">get_conditional_request_headers</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a2bb7b70431ed7cf389485b2f5514699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b293da5e31c3e461d8b625e5372462" id="r_af1b293da5e31c3e461d8b625e5372462"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1b293da5e31c3e461d8b625e5372462">HTTPCache</a> ()=delete</td></tr>
<tr class="separator:af1b293da5e31c3e461d8b625e5372462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7c3f5a41dd133f5599b1c5dd6fc8f4" id="r_a5f7c3f5a41dd133f5599b1c5dd6fc8f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f7c3f5a41dd133f5599b1c5dd6fc8f4">HTTPCache</a> (const <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp;)=delete</td></tr>
<tr class="separator:a5f7c3f5a41dd133f5599b1c5dd6fc8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8020123d2607755ededbca45e735e4" id="r_a2a8020123d2607755ededbca45e735e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a2a8020123d2607755ededbca45e735e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5567915b5e0a1f782928d43ae7c114df" id="r_a5567915b5e0a1f782928d43ae7c114df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5567915b5e0a1f782928d43ae7c114df">operator=</a> (const <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp;)=delete</td></tr>
<tr class="separator:a5567915b5e0a1f782928d43ae7c114df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee7fca59d1a37f495ea74c95fad600a" id="r_afee7fca59d1a37f495ea74c95fad600a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afee7fca59d1a37f495ea74c95fad600a">purge_cache</a> ()</td></tr>
<tr class="separator:afee7fca59d1a37f495ea74c95fad600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de0458e4ab0e89049a0f0fa7b819b91" id="r_a4de0458e4ab0e89049a0f0fa7b819b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4de0458e4ab0e89049a0f0fa7b819b91">release_cached_response</a> (FILE *response)</td></tr>
<tr class="separator:a4de0458e4ab0e89049a0f0fa7b819b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3dce74ad5dc45655491a0f289a9404" id="r_aae3dce74ad5dc45655491a0f289a9404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3dce74ad5dc45655491a0f289a9404">update_response</a> (const std::string &amp;url, time_t request_time, const std::vector&lt; std::string &gt; &amp;headers)</td></tr>
<tr class="separator:aae3dce74ad5dc45655491a0f289a9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fcde4b345c50bad6c3507dcbd2f447" id="r_ac8fcde4b345c50bad6c3507dcbd2f447"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8fcde4b345c50bad6c3507dcbd2f447">~HTTPCache</a> ()</td></tr>
<tr class="separator:ac8fcde4b345c50bad6c3507dcbd2f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5e69327f3853e99f88c74367f580128f" id="r_a5e69327f3853e99f88c74367f580128f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e69327f3853e99f88c74367f580128f">instance</a> (const std::string &amp;cache_root=&quot;&quot;)</td></tr>
<tr class="separator:a5e69327f3853e99f88c74367f580128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a76bd6ce419aad54c8c87e993f5bd11c9" id="r_a76bd6ce419aad54c8c87e993f5bd11c9"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76bd6ce419aad54c8c87e993f5bd11c9">HTTPCacheTest</a></td></tr>
<tr class="separator:a76bd6ce419aad54c8c87e993f5bd11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aed79b4a282abc0feb24f3e28234f13" id="r_a9aed79b4a282abc0feb24f3e28234f13"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aed79b4a282abc0feb24f3e28234f13">HTTPConnectTest</a></td></tr>
<tr class="separator:a9aed79b4a282abc0feb24f3e28234f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Accessors and Mutators for various properties.</h2></td></tr>
<tr class="memitem:a2c872a03a4065237cf384f778cceb126" id="r_a2c872a03a4065237cf384f778cceb126"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c872a03a4065237cf384f778cceb126">get_cache_root</a> () const</td></tr>
<tr class="separator:a2c872a03a4065237cf384f778cceb126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aa835c2b38bc0e891f40b5a77c53ce" id="r_a71aa835c2b38bc0e891f40b5a77c53ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71aa835c2b38bc0e891f40b5a77c53ce">set_cache_enabled</a> (bool mode)</td></tr>
<tr class="separator:a71aa835c2b38bc0e891f40b5a77c53ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9960970163436617a8753f95866c5a9" id="r_af9960970163436617a8753f95866c5a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9960970163436617a8753f95866c5a9">is_cache_enabled</a> () const</td></tr>
<tr class="separator:af9960970163436617a8753f95866c5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44857ae03334d09e34cc5b2275669a71" id="r_a44857ae03334d09e34cc5b2275669a71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44857ae03334d09e34cc5b2275669a71">set_cache_disconnected</a> (<a class="el" href="namespacelibdap.html#a49a7ae9e704d21900a5bebcb92ebae94">CacheDisconnectedMode</a> mode)</td></tr>
<tr class="separator:a44857ae03334d09e34cc5b2275669a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0745589ca1ed117b11efc52765a25b7e" id="r_a0745589ca1ed117b11efc52765a25b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibdap.html#a49a7ae9e704d21900a5bebcb92ebae94">CacheDisconnectedMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0745589ca1ed117b11efc52765a25b7e">get_cache_disconnected</a> () const</td></tr>
<tr class="separator:a0745589ca1ed117b11efc52765a25b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8c5f13e82c3038e97eca9979ebd39c" id="r_a1a8c5f13e82c3038e97eca9979ebd39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8c5f13e82c3038e97eca9979ebd39c">set_expire_ignored</a> (bool mode)</td></tr>
<tr class="separator:a1a8c5f13e82c3038e97eca9979ebd39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba172e9218a416213aa1d9f54e59e669" id="r_aba172e9218a416213aa1d9f54e59e669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba172e9218a416213aa1d9f54e59e669">is_expire_ignored</a> () const</td></tr>
<tr class="separator:aba172e9218a416213aa1d9f54e59e669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2447c27c88ebb29511379ede8ac5b6f" id="r_ab2447c27c88ebb29511379ede8ac5b6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2447c27c88ebb29511379ede8ac5b6f">set_max_size</a> (unsigned long size)</td></tr>
<tr class="separator:ab2447c27c88ebb29511379ede8ac5b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e89f36cc369c826aa6cd414adc06393" id="r_a7e89f36cc369c826aa6cd414adc06393"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e89f36cc369c826aa6cd414adc06393">get_max_size</a> () const</td></tr>
<tr class="separator:a7e89f36cc369c826aa6cd414adc06393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cc5b035dc08ae2704924002144fa29" id="r_a92cc5b035dc08ae2704924002144fa29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92cc5b035dc08ae2704924002144fa29">set_max_entry_size</a> (unsigned long size)</td></tr>
<tr class="separator:a92cc5b035dc08ae2704924002144fa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ec8c722b1c82124e697916b73036fe" id="r_a66ec8c722b1c82124e697916b73036fe"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66ec8c722b1c82124e697916b73036fe">get_max_entry_size</a> () const</td></tr>
<tr class="separator:a66ec8c722b1c82124e697916b73036fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca5c8c205241f62596e283943906386" id="r_a1ca5c8c205241f62596e283943906386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ca5c8c205241f62596e283943906386">set_default_expiration</a> (int exp_time)</td></tr>
<tr class="separator:a1ca5c8c205241f62596e283943906386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b03792f717b8d584e782d6797a1b331" id="r_a9b03792f717b8d584e782d6797a1b331"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b03792f717b8d584e782d6797a1b331">get_default_expiration</a> () const</td></tr>
<tr class="separator:a9b03792f717b8d584e782d6797a1b331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a13a18ec837e891e81823a4d30da47" id="r_aa9a13a18ec837e891e81823a4d30da47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9a13a18ec837e891e81823a4d30da47">set_always_validate</a> (bool validate)</td></tr>
<tr class="separator:aa9a13a18ec837e891e81823a4d30da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f59f69a7ca0c9104748e5a7cb07101" id="r_a95f59f69a7ca0c9104748e5a7cb07101"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95f59f69a7ca0c9104748e5a7cb07101">get_always_validate</a> () const</td></tr>
<tr class="separator:a95f59f69a7ca0c9104748e5a7cb07101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd04006a90df42c10e74ecc4160753a7" id="r_abd04006a90df42c10e74ecc4160753a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd04006a90df42c10e74ecc4160753a7">set_cache_control</a> (const std::vector&lt; std::string &gt; &amp;cc)</td></tr>
<tr class="separator:abd04006a90df42c10e74ecc4160753a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914885de0f7437e644df68157193efd5" id="r_a914885de0f7437e644df68157193efd5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a914885de0f7437e644df68157193efd5">get_cache_control</a> () const</td></tr>
<tr class="separator:a914885de0f7437e644df68157193efd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements a multi-process MT-safe HTTP 1.1 compliant (mostly) cache.</p>
<p><em>Clients that run as users lacking a writable HOME directory MUST disable this cache. Use Connect::set_cache_enable(false).</em></p>
<p>The original design of this class was taken from the W3C libwww software, written by Henrik Frystyk Nielsen, Copyright MIT 1995. See the file MIT_COPYRIGHT. This software is a complete rewrite in C++ with additional features useful to the DODS and OPeNDAP projects.</p>
<p>This cache does not implement range checking. Partial responses should not be cached (HFN's version did, but it doesn't mesh well with the DAP for which this is being written).</p>
<p>The cache uses the local file system to store responses. If it is being used in a MT application, care should be taken to ensure that the number of available file descriptors is not exceeded.</p>
<p>In addition, when used in a MT program only one thread should use the mutators to set property values. Even though the methods are robust WRT MT software, having several threads change values of cache's properties will lead to odd behavior on the part of the cache. Many of the public methods lock access to the class' interface. This is noted in the documentation for those methods.</p>
<p>Even though the public interface to the cache is typically locked when accessed, an extra locking mechanism is in place for &lsquo;entries&rsquo; which are accessed. If a thread accesses a entry, that response must be locked to prevent it from being updated until the thread tells the cache that it's no longer using it. The method get_cache_response() and get_cache_response_body() both lock an entry; use release_cache_response() to release the lock. Entries are locked using a combination of a counter and a mutex. The following methods block when called on a locked entry: <a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid()</a>, <a class="el" href="#a2bb7b70431ed7cf389485b2f5514699a">get_conditional_request_headers()</a>, <a class="el" href="#aae3dce74ad5dc45655491a0f289a9404">update_response()</a>. (The locking scheme could be modified so that a distinction is made between reading from and writing to an entry. In this case <a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid()</a> and <a class="el" href="#a2bb7b70431ed7cf389485b2f5514699a">get_conditional_request_headers()</a> would only lock when an entry is in use for writing. But I haven't done that.)</p>
<p>Update documentation: get_cache_response() now also serves as is_url_in_cache() and <a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid()</a> should only be called after a locked cached response is accessed using <a class="el" href="#a71b56b7bf4e26dc9dcdb8e9446c514f9">get_cached_response()</a>. These lock the cache for reading. The methods <a class="el" href="#a8d79d640be07aa8ea145247fccb775bf">cache_response()</a> and <a class="el" href="#aae3dce74ad5dc45655491a0f289a9404">update_response()</a> lock an entry for writing.</p>
<p>Check that the lock-for-write and lock-for-read work together since it's possible that an entry in use might have a stream of readers and never free the 'read-lock' thus blocking a writer.</p>
<dl class="section author"><dt>Author</dt><dd>James Gallagher <a href="#" onclick="location.href='mai'+'lto:'+'jga'+'ll'+'agh'+'er'+'@op'+'en'+'dap'+'.o'+'rg'; return false;">jgall<span class="obfuscator">.nosp@m.</span>aghe<span class="obfuscator">.nosp@m.</span>r@ope<span class="obfuscator">.nosp@m.</span>ndap<span class="obfuscator">.nosp@m.</span>.org</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8h_source.html#l00106">106</a> of file <a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1b293da5e31c3e461d8b625e5372462" name="af1b293da5e31c3e461d8b625e5372462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b293da5e31c3e461d8b625e5372462">&#9670;&#160;</a></span>HTTPCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libdap::HTTPCache::HTTPCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f7c3f5a41dd133f5599b1c5dd6fc8f4" name="a5f7c3f5a41dd133f5599b1c5dd6fc8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7c3f5a41dd133f5599b1c5dd6fc8f4">&#9670;&#160;</a></span>HTTPCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libdap::HTTPCache::HTTPCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8fcde4b345c50bad6c3507dcbd2f447" name="ac8fcde4b345c50bad6c3507dcbd2f447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fcde4b345c50bad6c3507dcbd2f447">&#9670;&#160;</a></span>~HTTPCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libdap::HTTPCache::~HTTPCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroy an instance of <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a>. This writes the cache index and frees the in-memory cache table structure. The persistent cache (the response headers and bodies and the index file) are not removed. To remove those, either erase the directory that contains the cache using a file system command or use the <a class="el" href="#afee7fca59d1a37f495ea74c95fad600a">purge_cache()</a> method (which leaves the cache directory structure in place but removes all the cached information). </p>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00124">124</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d79d640be07aa8ea145247fccb775bf" name="a8d79d640be07aa8ea145247fccb775bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d79d640be07aa8ea145247fccb775bf">&#9670;&#160;</a></span>cache_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCache::cache_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>request_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>headers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FILE *</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new response to the cache, or replace an existing cached response with new data. This method returns True if the information for <code>url</code> was added to the cache. A response might not be cache-able; in that case this method returns false. (For example, the response might contain the 'Cache-Control: no-cache' header.)</p>
<p>Note that the FILE *body is rewound so that the caller can re-read it without using fseek or rewind.</p>
<p>If a response for <code>url</code> is already present in the cache, it will be replaced by the new headers and body. To update a response in the cache with (only) new meta data, use <a class="el" href="#aae3dce74ad5dc45655491a0f289a9404">update_response()</a>.</p>
<p>This method locks the class' interface AND blocks until the cache can be locked for writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>A string which holds the request URL. </td></tr>
    <tr><td class="paramname">request_time</td><td>The time when the request was made, in seconds since 1 Jan 1970. </td></tr>
    <tr><td class="paramname">headers</td><td>A vector of strings which hold the response headers. </td></tr>
    <tr><td class="paramname">body</td><td>A FILE * to a file which holds the response body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the response was cached, False if the response could not be cached. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting.">InternalErr</a></td><td>Thrown if there was a I/O error while writing to the persistent store. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00898">898</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a95f59f69a7ca0c9104748e5a7cb07101" name="a95f59f69a7ca0c9104748e5a7cb07101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f59f69a7ca0c9104748e5a7cb07101">&#9670;&#160;</a></span>get_always_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCache::get_always_validate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should every cache entry be validated before each use? </p><dl class="section return"><dt>Returns</dt><dd>True if all cache entries require validation. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00631">631</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a914885de0f7437e644df68157193efd5" name="a914885de0f7437e644df68157193efd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914885de0f7437e644df68157193efd5">&#9670;&#160;</a></span>get_cache_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classstring.html">string</a> &gt; libdap::HTTPCache::get_cache_control </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the Cache-Control headers.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings, one string for each header. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00682">682</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a0745589ca1ed117b11efc52765a25b7e" name="a0745589ca1ed117b11efc52765a25b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0745589ca1ed117b11efc52765a25b7e">&#9670;&#160;</a></span>get_cache_disconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibdap.html#a49a7ae9e704d21900a5bebcb92ebae94">CacheDisconnectedMode</a> libdap::HTTPCache::get_cache_disconnected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the cache's disconnected mode property. </p>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00519">519</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a2c872a03a4065237cf384f778cceb126" name="a2c872a03a4065237cf384f778cceb126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c872a03a4065237cf384f778cceb126">&#9670;&#160;</a></span>get_cache_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstring.html">string</a> libdap::HTTPCache::get_cache_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current cache root directory. </p><dl class="section return"><dt>Returns</dt><dd>A string that contains the cache root directory. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00414">414</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a1b5138cebe8a7fa99c25bdedad967c95" name="a1b5138cebe8a7fa99c25bdedad967c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5138cebe8a7fa99c25bdedad967c95">&#9670;&#160;</a></span>get_cached_response() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * libdap::HTTPCache::get_cached_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to a cached response body. This is a convenience method that calls the three parameter version of get_cache_response().</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Find the body associated with this URL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A FILE* that points to the response body. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the URL is not in the cache. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting.">InternalErr</a></td><td>Thrown if an I/O error is detected. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01240">1240</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a562a4b33674f9fd51d0dde6afabb50bc" name="a562a4b33674f9fd51d0dde6afabb50bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562a4b33674f9fd51d0dde6afabb50bc">&#9670;&#160;</a></span>get_cached_response() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * libdap::HTTPCache::get_cached_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>headers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information from the cache. This is a convenience method that calls the three parameter version of get_cache_response().</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Get response information for this URL. </td></tr>
    <tr><td class="paramname">headers</td><td>Return the response headers in this parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A FILE * to the response body. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the URL's response is not in the cache. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting.">InternalErr</a></td><td>Thrown if the persistent store cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01225">1225</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a71b56b7bf4e26dc9dcdb8e9446c514f9" name="a71b56b7bf4e26dc9dcdb8e9446c514f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b56b7bf4e26dc9dcdb8e9446c514f9">&#9670;&#160;</a></span>get_cached_response() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE * libdap::HTTPCache::get_cached_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>headers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cacheName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get information from the cache. For a given URL, get the headers, cache object name and body stored in the cache. Note that this method increments the hit counter for <code>url</code>'s entry and <em>locks</em> that entry. To release the lock, the method <a class="el" href="#a4de0458e4ab0e89049a0f0fa7b819b91">release_cached_response()</a> <em>must</em> be called. Methods that block on a locked entry are: <a class="el" href="#a2bb7b70431ed7cf389485b2f5514699a">get_conditional_request_headers()</a>, <a class="el" href="#aae3dce74ad5dc45655491a0f289a9404">update_response()</a> and <a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid()</a>. In addition, <a class="el" href="#afee7fca59d1a37f495ea74c95fad600a">purge_cache()</a> throws <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> if it's called and any entries are locked. The garbage collection system will not reclaim locked entries (but works fine when some entries are locked).</p>
<p>This method locks the class' interface AND it read locks the cache. The cache will remain read locked until <a class="el" href="#a4de0458e4ab0e89049a0f0fa7b819b91">release_cached_response()</a> is called. There is no RAII protection for the cache read lock in this method.</p>
<p>This method does <em>not</em> check to see that the response is valid, just that it is in the cache. To see if a cached response is valid, use <a class="el" href="#a2a8020123d2607755ededbca45e735e4">is_url_valid()</a>. The FILE* returned can be used for both reading and writing. The latter allows a client to update the body of a cached response without having to first dump it all to a separate file and then copy it into the cache (using <a class="el" href="#a8d79d640be07aa8ea145247fccb775bf">cache_response()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Get response information for this URL. </td></tr>
    <tr><td class="paramname">headers</td><td>Return the response headers in this parameter </td></tr>
    <tr><td class="paramname">cacheName</td><td>A value-result parameter; the name of the cache file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A FILE * to the response body. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the URL's response is not in the cache. </td></tr>
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting.">InternalErr</a></td><td>Thrown if the persistent store cannot be opened. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01175">1175</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a2bb7b70431ed7cf389485b2f5514699a" name="a2bb7b70431ed7cf389485b2f5514699a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb7b70431ed7cf389485b2f5514699a">&#9670;&#160;</a></span>get_conditional_request_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvector.html">vector</a>&lt; <a class="el" href="classstring.html">string</a> &gt; libdap::HTTPCache::get_conditional_request_headers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the headers to send along with a GET request to make that request conditional. This method examines the headers for a given response in the cache and formulates the correct headers for a valid HTTP 1.1 conditional GET request. See RFC 2616, Section 13.3.4.</p>
<p>Rules: If an ETag is present, it must be used. Use If-None-Match. If a Last-Modified header is present, use it. Use If-Modified-Since. If both are present, use both (this means that HTTP 1.0 daemons are more likely to work). If a Last-Modified header is not present, use the value of the Cache-Control max-age or Expires header(s). Note that a 'Cache-Control: max-age' header overrides an Expires header (Sec 14.9.3).</p>
<p>This method locks the cache interface and the cache entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Get the <a class="el" href="structlibdap_1_1HTTPCacheTable_1_1CacheEntry.html">HTTPCacheTable::CacheEntry</a> for this URL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of strings, one request header per string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the <em>url</em> is not in the cache. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00973">973</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a9b03792f717b8d584e782d6797a1b331" name="a9b03792f717b8d584e782d6797a1b331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b03792f717b8d584e782d6797a1b331">&#9670;&#160;</a></span>get_default_expiration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libdap::HTTPCache::get_default_expiration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the default expiration time used by the cache. </p>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00620">620</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a66ec8c722b1c82124e697916b73036fe" name="a66ec8c722b1c82124e697916b73036fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ec8c722b1c82124e697916b73036fe">&#9670;&#160;</a></span>get_max_entry_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long libdap::HTTPCache::get_max_entry_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum size of an individual entry in the cache.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum size in megabytes. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00600">600</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a7e89f36cc369c826aa6cd414adc06393" name="a7e89f36cc369c826aa6cd414adc06393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e89f36cc369c826aa6cd414adc06393">&#9670;&#160;</a></span>get_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long libdap::HTTPCache::get_max_size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How big is the cache? The value returned is the size in megabytes. </p>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00572">572</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a5e69327f3853e99f88c74367f580128f" name="a5e69327f3853e99f88c74367f580128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e69327f3853e99f88c74367f580128f">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> * libdap::HTTPCache::instance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>cache_root</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a pointer to the HTTP 1.1 compliant cache. If not already instantiated, this creates an instance of the HTTP cache object and initializes it to use <code>cache_root</code> as the location of the persistent store. If there's an index (<code></code>.index) file in that directory, it is read as part of the initialization. If the cache has already been initialized, this method returns a pointer to that instance. Note <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> uses the singleton pattern; A process may have only one instance of this object. Also note that <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> is MT-safe.</p>
<p>Default values: <a class="el" href="#af9960970163436617a8753f95866c5a9">is_cache_enabled()</a>: true, is_cache_protected(): false, <a class="el" href="#aba172e9218a416213aa1d9f54e59e669">is_expire_ignored()</a>: false, the total size of the cache is 20M, 2M of that is reserved for response headers, during GC the cache is reduced to at least 18M (total size - 10% of the total size), and the max size for an individual entry is 3M. It is possible to change the size of the cache, but not to make it smaller than 5M. If expiration information is not sent with a response, it is assumed to expire in 24 hours.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_root</td><td>The fully qualified pathname of the directory which will hold the cache data (i.e., the persistent store). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> object. </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8h_source.html#l00269">269</a> of file <a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>.</p>

</div>
</div>
<a id="af9960970163436617a8753f95866c5a9" name="af9960970163436617a8753f95866c5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9960970163436617a8753f95866c5a9">&#9670;&#160;</a></span>is_cache_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCache::is_cache_enabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the cache currently enabled? </p>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00499">499</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="aba172e9218a416213aa1d9f54e59e669" name="aba172e9218a416213aa1d9f54e59e669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba172e9218a416213aa1d9f54e59e669">&#9670;&#160;</a></span>is_expire_ignored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCache::is_expire_ignored </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00538">538</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a2a8020123d2607755ededbca45e735e4" name="a2a8020123d2607755ededbca45e735e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8020123d2607755ededbca45e735e4">&#9670;&#160;</a></span>is_url_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libdap::HTTPCache::is_url_valid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look in the cache and return the status (validity) of the cached response. This method should be used to determine if a cached response requires validation.</p>
<p>This method locks the class' interface and the cache entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Find the cached response associated with this URL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True indicates that the response can be used, False indicates that it must first be validated. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the URL's response is not in the cache. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01093">1093</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a5567915b5e0a1f782928d43ae7c114df" name="a5567915b5e0a1f782928d43ae7c114df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5567915b5e0a1f782928d43ae7c114df">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp; libdap::HTTPCache::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afee7fca59d1a37f495ea74c95fad600a" name="afee7fca59d1a37f495ea74c95fad600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee7fca59d1a37f495ea74c95fad600a">&#9670;&#160;</a></span>purge_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::purge_cache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purge both the in-memory cache table and the contents of the cache on disk. This method deletes every entry in the persistent store but leaves the structure intact. The client of <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> is responsible for making sure that all threads have released any responses they pulled from the cache. If this method is called when a response is still in use, it will throw an <a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a> object and not purge the cache.</p>
<p>This method locks the class' interface.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if an attempt is made to purge the cache when an entry is still in use. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01278">1278</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a4de0458e4ab0e89049a0f0fa7b819b91" name="a4de0458e4ab0e89049a0f0fa7b819b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de0458e4ab0e89049a0f0fa7b819b91">&#9670;&#160;</a></span>release_cached_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::release_cached_response </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>body</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this method to inform the cache that a particular response is no longer in use. When a response is accessed using <a class="el" href="#a71b56b7bf4e26dc9dcdb8e9446c514f9">get_cached_response()</a>, it is locked so that updates and removal (e.g., by the garbage collector) are not possible. Calling this method frees that lock.</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>Release the lock on the response information associated with this FILE *. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if <code>body</code> does not belong to an entry in the cache or if the entry was already released. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01258">1258</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="aa9a13a18ec837e891e81823a4d30da47" name="aa9a13a18ec837e891e81823a4d30da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a13a18ec837e891e81823a4d30da47">&#9670;&#160;</a></span>set_always_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_always_validate </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>validate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should every cache entry be validated? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">validate</td><td>True if every cache entry should be validated before being used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00626">626</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="abd04006a90df42c10e74ecc4160753a7" name="abd04006a90df42c10e74ecc4160753a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd04006a90df42c10e74ecc4160753a7">&#9670;&#160;</a></span>set_cache_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_cache_control </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the request Cache-Control headers. If a request must be satisfied using HTTP, these headers should be included in request since they might be pertinent to a proxy cache.</p>
<p>Ignored headers: no-transform, only-if-cached. These headers are not used by <a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a> and are not recorded. However, if present in the vector passed to this method, they will be present in the vector returned by get_cache_control.</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cc</td><td>A vector of strings, each string holds one Cache-Control header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1InternalErr.html" title="A class for software fault reporting.">InternalErr</a></td><td>Thrown if one of the strings in <code>cc</code> does not start with 'Cache-Control: '. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00649">649</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a44857ae03334d09e34cc5b2275669a71" name="a44857ae03334d09e34cc5b2275669a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44857ae03334d09e34cc5b2275669a71">&#9670;&#160;</a></span>set_cache_disconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_cache_disconnected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibdap.html#a49a7ae9e704d21900a5bebcb92ebae94">CacheDisconnectedMode</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the cache's disconnected property. The cache can operate either disconnected from the network or using a proxy cache (but tell that proxy not to use the network).</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>One of DISCONNECT_NONE, DISCONNECT_NORMAL or DISCONNECT_EXTERNAL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>CacheDIsconnectedMode </dd></dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00511">511</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a71aa835c2b38bc0e891f40b5a77c53ce" name="a71aa835c2b38bc0e891f40b5a77c53ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71aa835c2b38bc0e891f40b5a77c53ce">&#9670;&#160;</a></span>set_cache_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_cache_enabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable the cache. The cache can be temporarily suspended using the enable/disable property. This does not prevent the cache from being enabled/disable at a later point in time.</p>
<p>Default: yes</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>True if the cache should be enabled, False if it should be disabled. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00491">491</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a1ca5c8c205241f62596e283943906386" name="a1ca5c8c205241f62596e283943906386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca5c8c205241f62596e283943906386">&#9670;&#160;</a></span>set_default_expiration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_default_expiration </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>exp_time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the default expiration time. Use the <em>default expiration</em> property to determine when a cached response becomes stale if the response lacks the information necessary to compute a specific value.</p>
<p>Default: 24 hours (86,400 seconds)</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exp_time</td><td>The time in seconds. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00612">612</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a1a8c5f13e82c3038e97eca9979ebd39c" name="a1a8c5f13e82c3038e97eca9979ebd39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8c5f13e82c3038e97eca9979ebd39c">&#9670;&#160;</a></span>set_expire_ignored()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_expire_ignored </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How should the cache handle the Expires header? Default: no</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>True if a responses Expires header should be ignored, False otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00529">529</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="a92cc5b035dc08ae2704924002144fa29" name="a92cc5b035dc08ae2704924002144fa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cc5b035dc08ae2704924002144fa29">&#9670;&#160;</a></span>set_max_entry_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_max_entry_size </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum size for a single entry in the cache.</p>
<p>Default: 3M</p>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size in megabytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00582">582</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="ab2447c27c88ebb29511379ede8ac5b6f" name="ab2447c27c88ebb29511379ede8ac5b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2447c27c88ebb29511379ede8ac5b6f">&#9670;&#160;</a></span>set_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::set_max_size </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cache size management. The default cache size is 20M. The minimum size is 5M in order not to get into weird problems while writing the cache. The size is indicated in Mega bytes. Note that reducing the size of the cache may trigger a garbage collection operation.</p>
<dl class="section note"><dt>Note</dt><dd>The maximum cache size is UINT_MAX bytes (usually 4294967295 for 32-bit computers). If <em>size</em> is larger the value will be truncated to the value of that constant. It seems pretty unlikely that will happen given that the parameter is an unsigned long. This is a fix for bug 689 which was reported when the parameter type was signed.</dd></dl>
<p>This method locks the class' interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum size of the cache in megabytes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l00555">555</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<a id="aae3dce74ad5dc45655491a0f289a9404" name="aae3dce74ad5dc45655491a0f289a9404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3dce74ad5dc45655491a0f289a9404">&#9670;&#160;</a></span>update_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libdap::HTTPCache::update_response </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>url</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t</td>          <td class="paramname"><span class="paramname"><em>request_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>headers</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the meta data for a response already in the cache. This method provides a way to merge response headers returned from a conditional GET request, for the given URL, with those already present.</p>
<p>This method locks the class' interface and the cache entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>Update the meta data for this cache entry. </td></tr>
    <tr><td class="paramname">request_time</td><td>The time (Unix time, seconds since 1 Jan 1970) that the conditional request was made. </td></tr>
    <tr><td class="paramname">headers</td><td>New headers, one header per string, returned in the response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classlibdap_1_1Error.html" title="A class for error processing.">Error</a></td><td>Thrown if the <code>url</code> is not in the cache. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="HTTPCache_8cc_source.html#l01032">1032</a> of file <a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a76bd6ce419aad54c8c87e993f5bd11c9" name="a76bd6ce419aad54c8c87e993f5bd11c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bd6ce419aad54c8c87e993f5bd11c9">&#9670;&#160;</a></span>HTTPCacheTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class HTTPCacheTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HTTPCache_8h_source.html#l00181">181</a> of file <a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>.</p>

</div>
</div>
<a id="a9aed79b4a282abc0feb24f3e28234f13" name="a9aed79b4a282abc0feb24f3e28234f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aed79b4a282abc0feb24f3e28234f13">&#9670;&#160;</a></span>HTTPConnectTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class HTTPConnectTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="HTTPCache_8h_source.html#l00182">182</a> of file <a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="HTTPCache_8h_source.html">HTTPCache.h</a></li>
<li><a class="el" href="HTTPCache_8cc_source.html">HTTPCache.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1HTTPCache.html">HTTPCache</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
