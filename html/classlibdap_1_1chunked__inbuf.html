<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libdap: libdap::chunked_inbuf Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libdap
   &#160;<span id="projectnumber">Updated for version 3.19.1</span>
   </div>
   <div id="projectbrief">libdap4 is an implementation of OPeNDAP&#39;s DAP protocol.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classlibdap_1_1chunked__inbuf.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classlibdap_1_1chunked__inbuf-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libdap::chunked_inbuf Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for libdap::chunked_inbuf:</div>
<div class="dyncontent">
<div class="center"><img src="classlibdap_1_1chunked__inbuf__inherit__graph.png" border="0" usemap="#libdap_1_1chunked__inbuf_inherit__map" alt="Inheritance graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6dda7c886ecd6d7d2b0e8658048a7e6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dda7c886ecd6d7d2b0e8658048a7e6f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>bytes_in_buffer</b> () const </td></tr>
<tr class="separator:a6dda7c886ecd6d7d2b0e8658048a7e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d2bc25f975262555a73e42ae13cf98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__inbuf.html#a26d2bc25f975262555a73e42ae13cf98">chunked_inbuf</a> (std::istream &amp;is, int size)</td></tr>
<tr class="memdesc:a26d2bc25f975262555a73e42ae13cf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a chunked input buffer.  <a href="#a26d2bc25f975262555a73e42ae13cf98">More...</a><br /></td></tr>
<tr class="separator:a26d2bc25f975262555a73e42ae13cf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717b8ac2da645d2a174fa1a04437857e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717b8ac2da645d2a174fa1a04437857e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>error</b> () const </td></tr>
<tr class="separator:a717b8ac2da645d2a174fa1a04437857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ce1d43c74ba715b2709c017ebb5434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6ce1d43c74ba715b2709c017ebb5434"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>error_message</b> () const </td></tr>
<tr class="separator:ac6ce1d43c74ba715b2709c017ebb5434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b29d2d6f5c4772e7950e8930ed71cb"><td class="memItemLeft" align="right" valign="top">int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__inbuf.html#a70b29d2d6f5c4772e7950e8930ed71cb">read_next_chunk</a> ()</td></tr>
<tr class="memdesc:a70b29d2d6f5c4772e7950e8930ed71cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a chunk Normally the chunked nature of a chunked_istream/chunked_inbuf is hidden from the caller. This method provides a way to get one chunk from the stream by forcing its read and returning the size. A subsequent call to read() for that number of bytes will return all of the data in the chunk. If there is any data in the chunk_inbuf object's buffer, it is lost.  <a href="#a70b29d2d6f5c4772e7950e8930ed71cb">More...</a><br /></td></tr>
<tr class="separator:a70b29d2d6f5c4772e7950e8930ed71cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d38ed16b70d8b2b98439797ce889e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3d38ed16b70d8b2b98439797ce889e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>twiddle_bytes</b> () const </td></tr>
<tr class="separator:ae3d38ed16b70d8b2b98439797ce889e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a45c0f6e2f7bfc6bd4f953e5de8dbd241"><td class="memItemLeft" align="right" valign="top">virtual int_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__inbuf.html#a45c0f6e2f7bfc6bd4f953e5de8dbd241">underflow</a> ()</td></tr>
<tr class="memdesc:a45c0f6e2f7bfc6bd4f953e5de8dbd241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new characters into the buffer This specialization of underflow is called when the gptr() is advanced to the end of the input buffer. At that point it calls the underlying I/O stream to read the next chunk of data and transfers the data read to the internal buffer. If an error is found, EOF is returned. If an END chunk with zero bytes is found, an EOF is returned.  <a href="#a45c0f6e2f7bfc6bd4f953e5de8dbd241">More...</a><br /></td></tr>
<tr class="separator:a45c0f6e2f7bfc6bd4f953e5de8dbd241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98a38a08d371dfb97c32c9235bbc129"><td class="memItemLeft" align="right" valign="top">virtual std::streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibdap_1_1chunked__inbuf.html#ac98a38a08d371dfb97c32c9235bbc129">xsgetn</a> (char *s, std::streamsize num)</td></tr>
<tr class="memdesc:ac98a38a08d371dfb97c32c9235bbc129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a block of data This specialization of <a class="el" href="classlibdap_1_1chunked__inbuf.html#ac98a38a08d371dfb97c32c9235bbc129" title="Read a block of data This specialization of xsgetn() reads num bytes and puts them in s first reading...">xsgetn()</a> reads <code>num</code> bytes and puts them in <code>s</code> first reading from the internal beffer and then from the stream. Any characters read from the last chunk that won't fit in to <code>s</code> are put in the buffer, otherwise all data are read directly into <code>s</code>, bypassing the internal buffer (and the extra copy operation that would imply). If the END chunk is found EOF is not returned and the final read of the underlying stream is not made; the next call to read(), get(), ..., will return EOF.  <a href="#ac98a38a08d371dfb97c32c9235bbc129">More...</a><br /></td></tr>
<tr class="separator:ac98a38a08d371dfb97c32c9235bbc129"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="chunked__istream_8h_source.html#l00042">42</a> of file <a class="el" href="chunked__istream_8h_source.html">chunked_istream.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a26d2bc25f975262555a73e42ae13cf98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libdap::chunked_inbuf::chunked_inbuf </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a chunked input buffer. </p>
<p>This reads from a chunked stream, extracting an entire chunk and storing it in a buffer in one operation. If the <a class="el" href="classlibdap_1_1chunked__inbuf.html">chunked_inbuf</a> reads a chunk header that indicates the next chunk is going be bigger than its current buffer size, the object will make the buffer larger. This object support 128 characters of 'put back' space. Since DAP4 uses receiver makes right, the buffer must be told if it should 'twiddle' the header size information. In DAP4 the byte order is sent using a one-byte code <em>before</em> the chunked transmission starts.</p>
<dl class="section note"><dt>Note</dt><dd>In the current implementation, the byte order of the sender is read from the first chunk header. The method twiddle_bytes() returns false until the first chunk is read, then it returns the correct value. Only the first chunk_header is tested for the byte order flag; all subsequent chunks are assumed to use the same byte order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Use this as a data source </td></tr>
    <tr><td class="paramname">size</td><td>The size of the input buffer. This should match the likely chunk size. If it is smaller than a chunk, it will be resized. </td></tr>
    <tr><td class="paramname">twiddle_bytes</td><td>Should the header bytes be twiddled? True if this host and the send use a different byte-order. The sender's byte order must be sent out-of-band. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="chunked__istream_8h_source.html#l00107">107</a> of file <a class="el" href="chunked__istream_8h_source.html">chunked_istream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a70b29d2d6f5c4772e7950e8930ed71cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_inbuf::read_next_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a chunk Normally the chunked nature of a chunked_istream/chunked_inbuf is hidden from the caller. This method provides a way to get one chunk from the stream by forcing its read and returning the size. A subsequent call to read() for that number of bytes will return all of the data in the chunk. If there is any data in the chunk_inbuf object's buffer, it is lost. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read, which is exactly the size of the next chunk in the stream. Returns EOF on error. </dd></dl>

<p>Definition at line <a class="el" href="chunked__istream_8cc_source.html#l00341">341</a> of file <a class="el" href="chunked__istream_8cc_source.html">chunked_istream.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a45c0f6e2f7bfc6bd4f953e5de8dbd241"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streambuf::int_type libdap::chunked_inbuf::underflow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new characters into the buffer This specialization of underflow is called when the gptr() is advanced to the end of the input buffer. At that point it calls the underlying I/O stream to read the next chunk of data and transfers the data read to the internal buffer. If an error is found, EOF is returned. If an END chunk with zero bytes is found, an EOF is returned. </p>
<dl class="section return"><dt>Returns</dt><dd>The character at the gptr() or EOF </dd></dl>

<p>Definition at line <a class="el" href="chunked__istream_8cc_source.html#l00085">85</a> of file <a class="el" href="chunked__istream_8cc_source.html">chunked_istream.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac98a38a08d371dfb97c32c9235bbc129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::streamsize libdap::chunked_inbuf::xsgetn </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::streamsize&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a block of data This specialization of <a class="el" href="classlibdap_1_1chunked__inbuf.html#ac98a38a08d371dfb97c32c9235bbc129" title="Read a block of data This specialization of xsgetn() reads num bytes and puts them in s first reading...">xsgetn()</a> reads <code>num</code> bytes and puts them in <code>s</code> first reading from the internal beffer and then from the stream. Any characters read from the last chunk that won't fit in to <code>s</code> are put in the buffer, otherwise all data are read directly into <code>s</code>, bypassing the internal buffer (and the extra copy operation that would imply). If the END chunk is found EOF is not returned and the final read of the underlying stream is not made; the next call to read(), get(), ..., will return EOF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a buffer to hold the data </td></tr>
    <tr><td class="paramname">num</td><td>Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NUmber of bytes actually transferred into <code>s</code>. Note that this number does not include the bytes read from the last chunk that won't fit into <code>s</code> so this will never return a number greater than num. </dd></dl>

<p>Definition at line <a class="el" href="chunked__istream_8cc_source.html#l00185">185</a> of file <a class="el" href="chunked__istream_8cc_source.html">chunked_istream.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="chunked__istream_8h_source.html">chunked_istream.h</a></li>
<li><a class="el" href="chunked__istream_8cc_source.html">chunked_istream.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibdap.html">libdap</a></li><li class="navelem"><a class="el" href="classlibdap_1_1chunked__inbuf.html">chunked_inbuf</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
